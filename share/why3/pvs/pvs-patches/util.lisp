;;
;; Utility functions and helpers to prove verificiation conditions
;; generated by Frama-C.
;;

;;
;; Frama-C Literals
;;

;; @M3 #WIP
;; #TODO support for single precision literals
(defstep install-all-framac-literals-as-rewritting-rules ()
  ;; This proof step collects all the axioms from the current module
  ;; whose names start with the prefix "fliteral_axiom".
  (let ((values
	 (loop for decl in (all-decls (module (current-theory)))
	       when (and
		     (axiom? decl)
		     (prefix? "fliteral_axiom" (format nil "~a" (id decl))))
	       collect (get-framac-literal-information-from-axiom decl))))
    (for-each-value*$
     (if (= value 0) (skip) (autorewrite-framac-literal$ literal value))
     (literal value)
     values))
  "Install all the definitions of literals introduced by Frama-C
   as rewriting rules in the current proof."
  "Installing literal definitions as rewriting rules...")

(defmacro literal-axiom-name (literal-idx)
  '(if literal-idx (format nil "fliteral_axiom~a" literal-idx) "fliteral_axiom"))

;; @M3 #WIP
;; #PRE value /= 0 (the case value=0 should be taken care of by the caller)
;; #TODO downgrade to helper
(defstep autorewrite-framac-literal (literal-idx value &optional (double? t))
  (let((literal-name (format nil "fliteral~a" (if literal-idx literal-idx "")))
       ;;
       (is-finite-hypothesis
	(format nil "~a(~a(~a))" (isfinite?-fn double?) (round-fn double?) value))
       (literal-value-hypothesis
	(format nil "~a = ~a(~a)" literal-name (round-fn double?) value))
       (case-str
	(format nil "NOT (~a AND ~a)" is-finite-hypothesis literal-value-hypothesis))
       ;;
       (round-proj-lm (round-proj-lm double?))
       ;;
       (dummy (format t "~&Introducing hypothesis for literal ~a (value: ~a)~%"
		      literal-name value)))
    (spread 
     (case case-str)
     ((let ((axiom-name (literal-axiom-name literal-idx))
	    (round-proj-lm (round-proj-lm double?)))
	(then
	 (hide-all-but 1)
	 (use axiom-name)
	 (assert)
	 (flatten)
	 (expand "safe_proj")
	 (assert)
	 (replace -2 :dir rl)
	 (rewrite round-proj-lm)
	 (rewrite "nzfinite?_def")))
      ;; The second branch is the main branch (to be continued by the caller proof step.
      (then
       ;; the top-most formula in this goal should be
       ;;  {-1}  (finite?(round(2)) AND fliteral = round(2))
       ;; the formula is flattened and both sub-formulas are installed as
       ;; rewriting rules and then hidden.
       (flatten -1)
       (auto-rewrite -1)
       (hide -1)
       (auto-rewrite -1)
       (hide -1)))))
    "Install as a rewriting rule the definition of the given literal,
     introduced by Frama-C during the translation from C to why3."
    "Apply autorewrite-framac-literal helper.")

(defun get-framac-literal-information-from-axiom (axiom-decl)
  "Returns the index and the value of the frama-c literal defined by the
   axiom AXIOM-DECL (defcl declaration)."
  (list
   ;; take the name of the literal from the axiom name
   (let*((axiom-name (format nil "~a" (id axiom-decl)))
	 (idx-str    (subseq axiom-name 14))) ;; (length "fliteral_axiom") -> 14
     (if (eq (length idx-str) 0) nil (parse-integer idx-str)))
   ;; take its value from the axiom definition. 
   ;; The axiom is known to have the form
   ;;  is_finite?(fliteral) AND (safe_prjct_double(fliteral) = (1 * 2))
   (eval(pvs2cl(args2(args2(definition axiom-decl)))))))
