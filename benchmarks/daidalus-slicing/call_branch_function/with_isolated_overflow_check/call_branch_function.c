// This file is automatically generated by PRECiSA

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_sat {
logic real sat (real x, real thr) =
((x - thr) < 0) ? (x) : (thr);
}
*/


/*@
axiomatic fp_function_sat {

  predicate sat_fp_ov (double x_double, double thr_double) =
    (Dsub_ov(x_double, thr_double));

  logic double sat_fp (double x_double, double thr_double) =
    (Dsub(x_double, thr_double) < (double) (0)) ? (x_double) : (thr_double);
}
*/


/*@ axiomatic sat_trans {
predicate sat_stable_paths (real x, real thr, double x_double, double thr_double) =
((! (((x - thr) < 0)) && ! ((Dsub(x_double, thr_double) < (double) (0)))) || (((x - thr) < 0) && (Dsub(x_double, thr_double) < (double) (0))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures ((\result.isValid && !sat_fp_ov(x_double, thr_double) &&  \is_finite(E_0_double))
         ==> ((\result.value == sat_fp(x_double, thr_double)))) ;

behavior stable_paths:
ensures ((((((\is_finite(\result.value) && \is_finite(x_double)) && \is_finite(thr_double)) && \is_finite(E_0_double)) && \is_finite(Dsub(x_double, thr_double))) && \is_finite((double) (0)))
         ==> (\forall real x, real thr; ((\abs(Dsub(x_double, thr_double) - (x - thr)) <= E_0_double
                                          ==> (sat_stable_paths(x, thr, x_double, thr_double)))))) ;
*/
struct maybeDouble sat_fp (double x_double, double thr_double, double E_0_double) {
  struct maybeDouble res_double;
  if ((x_double - thr_double) < - (E_0_double))
  { res_double = someDouble(x_double);
  } else { if ((x_double - thr_double) >= E_0_double)
           { res_double = someDouble(thr_double);
           } else { res_double = noneDouble();
           }
  }
  return res_double;
}


/*@ lemma no_ov: \forall real x, real thr, double x_double, double thr_double;
(1 <= x && x <= 2 && 1 <= thr && thr <= 2
&&
(\abs(x_double - x) <= ulp_dp(x)/2
&&
\abs(thr_double - thr) <= ulp_dp(thr)/2)
&&
\abs(x - thr) + 0x1p-52 <= DBL_MAX) ==> !sat_fp_ov(x_double, thr_double);
*/



/*@
assigns \nothing;
ensures
\forall real x, real thr; 1 <= x && x <= 2 && 1 <= thr && thr <= 2
==> \abs(x - thr) + 0x1p-52 <= DBL_MAX;

ensures
\forall real x, real thr; (1 <= x && x <= 2 && 1 <= thr && thr <= 2
&&
\result.isValid
&&
!sat_fp_ov(x_double, thr_double)
&&
\abs(x_double - x) <= ulp_dp(x)/2
&&
\abs(thr_double - thr) <= ulp_dp(thr)/2)
==> \abs(\result.value - sat(x, thr)) <= 0x1p-52 ;
*/
struct maybeDouble sat_num (double x_double, double thr_double) {
  return sat_fp (x_double, thr_double, 0x1.4p-51);
}


/*@
axiomatic real_function_sat_1 {
logic real sat_1 (real x, real thr) =
sat((x + 1), thr);
}
*/


/*@
axiomatic fp_function_sat_1 {
  predicate sat_1_fp_ov (double x_double, double thr_double) =
    (Dadd_ov(x_double, (double) 1) ||
     sat_fp_ov(Dadd(x_double, (double) (1)), thr_double));

  logic double sat_1_fp (double x_double, double thr_double) =
    sat_fp(Dadd(x_double, (double) (1)), thr_double);
}
*/


/*@ axiomatic sat_1_trans {
predicate sat_1_stable_paths (real x, real thr, double x_double, double thr_double) =
((! ((((x + 1) - thr) < 0)) && ! ((Dsub(Dadd(x_double, (double) (1)), thr_double) < (double) (0)))) || ((((x + 1) - thr) < 0) && (Dsub(Dadd(x_double, (double) (1)), thr_double) < (double) (0))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures ((\result.isValid && \is_finite(\result.value) && !sat_1_fp_ov(x_double, thr_double) &&  \is_finite(E_0_double))
         ==> ((\result.value == sat_1_fp(x_double, thr_double)))) ;

behavior stable_paths:
ensures ((((\is_finite(\result.value) && \is_finite(x_double)) && \is_finite(thr_double)) && \is_finite(E_0_double))
         ==> (\forall real x, real thr; ((\abs(Dsub(Dadd(x_double, (double) (1)), thr_double) - ((x + 1) - thr)) <= E_0_double
                                          ==> (sat_1_stable_paths(x, thr, x_double, thr_double)))))) ;
*/
struct maybeDouble sat_1_fp (double x_double, double thr_double, double E_0_double) {
  struct maybeDouble res_double;
  res_double = someDouble(sat_fp ((x_double + (double)(1)), thr_double, E_0_double).value);
  return res_double;
}


/*@
assigns \nothing;
ensures (\forall real x, real thr; (((((1 <= x) && (x <= 2)) && ((1 <= thr) && (thr <= 2))) && ((\result.isValid && ((\is_finite(\result.value) && \is_finite(x_double)) && \is_finite(thr_double))) && (\abs(x_double - x) <= ulp_dp(x)/2 && \abs(thr_double - thr) <= ulp_dp(thr)/2))))
         ==> ((\abs((\result.value - sat_1(x, thr))) <= 0x1p-51))) ;
*/
struct maybeDouble sat_1_num (double x_double, double thr_double) {
  return sat_1_fp (x_double, thr_double, 0x1p-50);
}


int main () { return 0; }