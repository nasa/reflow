// This file is automatically generated by PRECiSA

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_sat {
logic real sat (real x, real thr) =
((x - thr) < 0) ? (x) : (thr);
}
*/


/*@
axiomatic fp_function_sat {
logic double_ov sat_fp (double_ov x_double, double_ov thr_double) =
  Dif(Dsub(x_double, thr_double), x_double, thr_double);
}
*/


/*@ axiomatic sat_trans {
predicate sat_stable_paths (real x, real thr, double x_double, double thr_double) =
  ((! (((x - thr) < 0)) && ! ((Dsub(DoubleOV(x_double), DoubleOV(thr_double)).value < (double) (0)))) || (((x - thr) < 0) && (Dsub(DoubleOV(x_double), DoubleOV(thr_double)).value < (double) (0))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures ((\result.isValid && ((\is_finite(\result.value) && !sat_fp(DoubleOV(x_double), DoubleOV(thr_double)).overflow && \is_finite(E_0_double)) ) && \is_finite((double) (0))))
         ==> ((\result.value == sat_fp(DoubleOV(x_double), DoubleOV(thr_double)).value )) ;

behavior stable_paths:
ensures ((((((\is_finite(\result.value) && \is_finite(x_double)) && \is_finite(thr_double)) && \is_finite(E_0_double)) && \is_finite(Dsub(DoubleOV(x_double), DoubleOV(thr_double)).value)) && \is_finite((double) (0)))
         ==> (\forall real x, real thr; ((\abs(Dsub(DoubleOV(x_double), DoubleOV(thr_double)).value - (x - thr)) <= E_0_double
                                          ==> (sat_stable_paths(x, thr, x_double, thr_double)))))) ;
*/
struct maybeDouble sat_fp (double x_double, double thr_double, double E_0_double) {
  struct maybeDouble res_double;
  if ((x_double - thr_double) < - (E_0_double))
  { res_double = someDouble(x_double);
  } else { if ((x_double - thr_double) >= E_0_double)
           { res_double = someDouble(thr_double);
           } else { res_double = noneDouble();
           }
  }
  return res_double;
}


/*@
assigns \nothing;
ensures (\forall real x, real thr; (((((1 <= x) && (x <= 2)) && ((1 <= thr) && (thr <= 2))) && ((\result.isValid && ((((\is_finite(\result.value) && \is_finite(x_double)) && \is_finite(thr_double)) && \is_finite(Dsub(DoubleOV(x_double), DoubleOV(thr_double)).value)) && \is_finite((double) (0)))) && (\abs(x_double - x) <= ulp_dp(x)/2 && \abs(thr_double - thr) <= ulp_dp(thr)/2))))
         ==> ((\abs((\result.value - sat(x, thr))) <= 0x1p-52))) ;
*/
struct maybeDouble sat_num (double x_double, double thr_double) {
  return sat_fp (x_double, thr_double, 0x1.4p-51);
}


/*@
axiomatic real_function_sat_1 {
logic real sat_1 (real x, real thr) =
sat((x + 1), thr);
}
*/


/*@
axiomatic fp_function_sat_1 {
logic double_ov sat_1_fp (double_ov x_double, double_ov thr_double) =
  sat_fp(Dadd(x_double, DoubleOV((double) (1))), thr_double);
}
*/


/*@ axiomatic sat_1_trans {
predicate sat_1_stable_paths (real x, real thr, double x_double, double thr_double) =
  ((! ((((x + 1) - thr) < 0)) && ! ((Dsub(Dadd(DoubleOV(x_double), DoubleOV((double) (1))), DoubleOV(thr_double)).value < (double) (0)))) || ((((x + 1) - thr) < 0) && (Dsub(Dadd(DoubleOV(x_double), DoubleOV((double) (1))), DoubleOV(thr_double)).value < (double) (0))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures ((\result.isValid && (\is_finite(\result.value) && !sat_1_fp(DoubleOV(x_double), DoubleOV(thr_double)).overflow && \is_finite(E_0_double)))
         ==> ((\result.value == sat_1_fp(DoubleOV(x_double), DoubleOV(thr_double)).value))) ;

behavior stable_paths:
ensures ((((\is_finite(\result.value) && \is_finite(x_double)) && \is_finite(thr_double)) && \is_finite(E_0_double))
         ==> (\forall real x, real thr; ((\abs(Dsub(Dadd(DoubleOV(x_double), DoubleOV((double) (1))), DoubleOV(thr_double)).value - ((x + 1) - thr)) <= E_0_double
                                          ==> (sat_1_stable_paths(x, thr, x_double, thr_double)))))) ;
*/
struct maybeDouble sat_1_fp (double x_double, double thr_double, double E_0_double) {
  struct maybeDouble res_double;
  res_double = someDouble(sat_fp ((x_double + (double)(1)), thr_double, E_0_double).value);
  return res_double;
}


/*@
assigns \nothing;
ensures (\forall real x, real thr; (((((1 <= x) && (x <= 2)) && ((1 <= thr) && (thr <= 2))) && ((\result.isValid && ((\is_finite(\result.value) && \is_finite(x_double)) && \is_finite(thr_double))) && (\abs(x_double - x) <= ulp_dp(x)/2 && \abs(thr_double - thr) <= ulp_dp(thr)/2))))
         ==> ((\abs((\result.value - sat_1(x, thr))) <= 0x1p-51))) ;
*/
struct maybeDouble sat_1_num (double x_double, double thr_double) {
  return sat_1_fp (x_double, thr_double, 0x1p-50);
}


int main () { return 0; }