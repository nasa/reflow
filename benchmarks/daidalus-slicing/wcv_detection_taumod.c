// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_tcoa {
logic real tcoa (real sz, real vz) =
((sz * vz) < 0) ? (-((sz / vz))) : (-1);
}
*/


/*@
axiomatic fp_function_tcoa {
logic double tcoa_fp (double sz_double, double vz_double) =
(Dmul(sz_double, vz_double) < (double) (0)) ? (Dneg(Ddiv(sz_double, vz_double))) : ((double) (-1));
}
*/


/*@ axiomatic tcoa_trans {
predicate tcoa_stable_paths (real sz, real vz, double sz_double, double vz_double) =
((((vz != 0) && ((sz * vz) < 0)) && ((vz_double != (double) (0)) && (Dmul(sz_double, vz_double) < (double) (0)))) || (! (((sz * vz) < 0)) && ! ((Dmul(sz_double, vz_double) < (double) (0)))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures ((\result.isValid && (\is_finite(\result.value) && ((\is_finite(sz_double) && \is_finite(vz_double)) && \is_finite(E_0_double))))
         ==> ((\result.value == tcoa_fp(sz_double, vz_double)))) ;

behavior stable_paths:
ensures \forall real sz, real vz; ((\abs(Dmul(sz_double, vz_double) - (sz * vz)) <= E_0_double
                                    ==> (((((\is_finite(sz_double) && \is_finite(vz_double)) && \is_finite(E_0_double)) && \result.isValid)
                                          ==> (tcoa_stable_paths(sz, vz, sz_double, vz_double)))))) ;
*/
struct maybeDouble tcoa_fp (double sz_double, double vz_double, double E_0_double) {
  struct maybeDouble res_double;
  if ((sz_double * vz_double) < - (E_0_double))
  { res_double = someDouble(- ((sz_double / vz_double)));
  } else { if ((sz_double * vz_double) >= E_0_double)
           { res_double = someDouble((double)(-1));
           } else { res_double = noneDouble();
           }
  }
  return res_double;
}


/*@
assigns \nothing;
ensures \forall real sz, real vz; ((((((0 <= sz) && (sz <= 1000)) && ((400 <= vz) && (vz <= 600))) && ((\result.isValid && (\is_finite(sz_double) && \is_finite(vz_double))) && (\abs(sz_double - sz) <= ulp_dp(sz)/2 && \abs(vz_double - vz) <= ulp_dp(vz)/2)))
                                    ==> ((\abs((\result.value - tcoa(sz, vz))) <= 0x1.c7ae147ae147dp-51)))) ;
*/
struct maybeDouble tcoa_num (double sz_double, double vz_double) {
  return tcoa_fp (sz_double, vz_double, 0x1.4800000000001p-33);
}


/*@
axiomatic real_function_tcpa {
logic real tcpa (real sx, real vx, real sy, real vy) =
(((vx * vx) + (vy * vy)) > 0) ? ((-(((sx * vx) + (sy * vy))) / ((vx * vx) + (vy * vy)))) : (0);
}
*/


/*@
axiomatic fp_function_tcpa {
logic double tcpa_fp (double sx_double, double vx_double, double sy_double, double vy_double) =
(Dadd(Dmul(vx_double, vx_double), Dmul(vy_double, vy_double)) > (double) (0)) ? (Ddiv(Dneg(Dadd(Dmul(sx_double, vx_double), Dmul(sy_double, vy_double))), Dadd(Dmul(vx_double, vx_double), Dmul(vy_double, vy_double)))) : ((double) (0));
}
*/


/*@ axiomatic tcpa_trans {
predicate tcpa_stable_paths (real sx, real vx, real sy, real vy, double sx_double, double vx_double, double sy_double, double vy_double) =
((((((vx * vx) + (vy * vy)) != 0) && (((vx * vx) + (vy * vy)) > 0)) && ((Dadd(Dmul(vx_double, vx_double), Dmul(vy_double, vy_double)) != (double) (0)) && (Dadd(Dmul(vx_double, vx_double), Dmul(vy_double, vy_double)) > (double) (0)))) || (! ((((vx * vx) + (vy * vy)) > 0)) && ! ((Dadd(Dmul(vx_double, vx_double), Dmul(vy_double, vy_double)) > (double) (0)))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures ((\result.isValid && (\is_finite(\result.value) && ((((\is_finite(sx_double) && \is_finite(vx_double)) && \is_finite(sy_double)) && \is_finite(vy_double)) && \is_finite(E_0_double))))
         ==> ((\result.value == tcpa_fp(sx_double, vx_double, sy_double, vy_double)))) ;

behavior stable_paths:
ensures \forall real sx, real vx, real sy, real vy; ((\abs(Dadd(Dmul(vx_double, vx_double), Dmul(vy_double, vy_double)) - ((vx * vx) + (vy * vy))) <= E_0_double
                                                      ==> (((((((\is_finite(sx_double) && \is_finite(vx_double)) && \is_finite(sy_double)) && \is_finite(vy_double)) && \is_finite(E_0_double)) && \result.isValid)
                                                            ==> (tcpa_stable_paths(sx, vx, sy, vy, sx_double, vx_double, sy_double, vy_double)))))) ;
*/
struct maybeDouble tcpa_fp (double sx_double, double vx_double, double sy_double, double vy_double, double E_0_double) {
  struct maybeDouble res_double;
  if (((vx_double * vx_double) + (vy_double * vy_double)) > E_0_double)
  { res_double = someDouble((- (((sx_double * vx_double) + (sy_double * vy_double))) / ((vx_double * vx_double) + (vy_double * vy_double))));
  } else { if (((vx_double * vx_double) + (vy_double * vy_double)) <= - (E_0_double))
           { res_double = someDouble((double)(0));
           } else { res_double = noneDouble();
           }
  }
  return res_double;
}


/*@
assigns \nothing;
ensures \forall real sx, real vx, real sy, real vy; ((((((((1 <= sx) && (sx <= 2)) && ((1 <= vx) && (vx <= 2))) && ((1 <= sy) && (sy <= 2))) && ((1 <= vy) && (vy <= 2))) && ((\result.isValid && (((\is_finite(sx_double) && \is_finite(vx_double)) && \is_finite(sy_double)) && \is_finite(vy_double))) && (((\abs(sx_double - sx) <= ulp_dp(sx)/2 && \abs(vx_double - vx) <= ulp_dp(vx)/2) && \abs(sy_double - sy) <= ulp_dp(sy)/2) && \abs(vy_double - vy) <= ulp_dp(vy)/2)))
                                                      ==> ((\abs((\result.value - tcpa(sx, vx, sy, vy))) <= 0x1.2ac0000000014p-47)))) ;
*/
struct maybeDouble tcpa_num (double sx_double, double vx_double, double sy_double, double vy_double) {
  return tcpa_fp (sx_double, vx_double, sy_double, vy_double, 0x1.0000000000001p-48);
}


int main () { return 0; }