// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_quadrant {
logic integer quadrant (real X, real Y) =
(((0 <= X) && (0 <= Y)))
? 1 :
(((X <= 0) && (0 <= Y)))
? 2 :
((X <= 0))
? 3 :
4;
}
*/


/*@
axiomatic fp_function_quadrant {
logic integer quadrant_fp (double X_double, double Y_double) =
((((double) (0) <= X_double) && ((double) (0) <= Y_double)))
? 1 :
(((X_double <= (double) (0)) && ((double) (0) <= Y_double)))
? 2 :
((X_double <= (double) (0)))
? 3 :
4;
}
*/


/*@ axiomatic quadrant_trans {
predicate quadrant_stable_paths (real X, real Y, double X_double, double Y_double) =
(((((((X <= 0) && (0 <= Y)) && ! (((0 <= X) && (0 <= Y)))) && ((((X_double <= (double) (0)) && ((double) (0) <= Y_double)) && ! ((((double) (0) <= X_double) && ((double) (0) <= Y_double)))) && (\true && \true))) || ((! ((X <= 0)) && (! (((X <= 0) && (0 <= Y))) && ! (((0 <= X) && (0 <= Y))))) && ((! ((X_double <= (double) (0))) && (! (((X_double <= (double) (0)) && ((double) (0) <= Y_double))) && ! ((((double) (0) <= X_double) && ((double) (0) <= Y_double))))) && (\true && \true)))) || (((0 <= X) && (0 <= Y)) && ((((double) (0) <= X_double) && ((double) (0) <= Y_double)) && (\true && \true)))) || (((X <= 0) && (! (((X <= 0) && (0 <= Y))) && ! (((0 <= X) && (0 <= Y))))) && (((X_double <= (double) (0)) && (! (((X_double <= (double) (0)) && ((double) (0) <= Y_double))) && ! ((((double) (0) <= X_double) && ((double) (0) <= Y_double))))) && (\true && \true))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures ((\result.isValid && (\is_finite(\result.value) && (((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double))))
         ==> ((\result.value == quadrant_fp(X_double, Y_double)))) ;

behavior stable_paths:
ensures \forall real X, real Y; (((\abs(X_double - X) <= E_0_double && \abs(Y_double - Y) <= E_1_double)
                                  ==> ((((((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double)) && \result.isValid)
                                        ==> (quadrant_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeInt quadrant_fp (double X_double, double Y_double, double E_0_double, double E_1_double) {
  struct maybeInt res;
  if ((E_0_double <= X_double) && (E_1_double <= Y_double))
  { res = some(1);;
  }
  else if (((X_double <= - (E_0_double)) && (E_1_double <= Y_double)) && ((- (E_0_double) > X_double) || (- (E_1_double) > Y_double)))
  { res = some(2);; }
  else if (((X_double <= - (E_0_double)) && ((X_double > E_0_double) || (- (E_1_double) > Y_double))) && ((- (E_0_double) > X_double) || (- (E_1_double) > Y_double)))
  { res = some(3);; }
  else if (((X_double > E_0_double) && ((X_double > E_0_double) || (- (E_1_double) > Y_double))) && ((- (E_0_double) > X_double) || (- (E_1_double) > Y_double)))
  { res = some(4);; }
  else { res = none();
  }
  return res;
}


/*@
assigns \nothing;
ensures \forall real X, real Y; ((((((-60000 <= X) && (X <= 60000)) && ((-10000 <= Y) && (Y <= 10000))) && ((\result.isValid && (\is_finite(X_double) && \is_finite(Y_double))) && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2)))
                                  ==> ((\abs((\result.value - quadrant(X, Y))) <= 0x0p+0)))) ;
*/
struct maybeInt quadrant_num (double X_double, double Y_double) {
  return quadrant_fp (X_double, Y_double, 0x1p-38, 0x1p-40);
}


/*@
axiomatic real_pred_first_quadrant {
logic boolean first_quadrant (real X, real Y) =
((quadrant(X, Y) - 1) == 0);
}
*/


/*@
axiomatic fp_pred_first_quadrant {
logic boolean first_quadrant_fp (double X_double, double Y_double) =
(Isub(quadrant_fp(X_double, Y_double), 1) == 0);
}
*/


/*@ axiomatic first_quadrant_trans {
predicate first_quadrant_stable_paths (real X, real Y, double X_double, double Y_double) =
(((((((X <= 0) && (0 <= Y)) && ! (((0 <= X) && (0 <= Y)))) && ((((X_double <= (double) (0)) && ((double) (0) <= Y_double)) && ! ((((double) (0) <= X_double) && ((double) (0) <= Y_double)))) && (\true && \true))) || ((! ((X <= 0)) && (! (((X <= 0) && (0 <= Y))) && ! (((0 <= X) && (0 <= Y))))) && ((! ((X_double <= (double) (0))) && (! (((X_double <= (double) (0)) && ((double) (0) <= Y_double))) && ! ((((double) (0) <= X_double) && ((double) (0) <= Y_double))))) && (\true && \true)))) || (((0 <= X) && (0 <= Y)) && ((((double) (0) <= X_double) && ((double) (0) <= Y_double)) && (\true && \true)))) || (((X <= 0) && (! (((X <= 0) && (0 <= Y))) && ! (((0 <= X) && (0 <= Y))))) && (((X_double <= (double) (0)) && (! (((X_double <= (double) (0)) && ((double) (0) <= Y_double))) && ! ((((double) (0) <= X_double) && ((double) (0) <= Y_double))))) && (\true && \true))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures \forall real X, real Y; (((\result.isValid && (((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double)))
                                  ==> (((\result.value
                                         ==> ((first_quadrant(X, Y) && first_quadrant_fp(X_double, Y_double)))) && (! (\result.value)
                                                                                                                    ==> ((! (first_quadrant(X, Y)) && ! (first_quadrant_fp(X_double, Y_double))))))))) ;

behavior stable_paths:
ensures \forall real X, real Y; (((\abs(X_double - X) <= E_0_double && \abs(Y_double - Y) <= E_1_double)
                                  ==> ((((((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double)) && \result.isValid)
                                        ==> (first_quadrant_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeBool first_quadrant_fp (double X_double, double Y_double, double E_0_double, double E_1_double) {
  struct maybeBool res;
  struct maybeInt aux_0 = quadrant_fp (X_double, Y_double, E_0_double, E_1_double);
  if (aux_0.isValid)
  { res = someBool((aux_0.value - 1) == 0);
  } else { res = noneBool();
  }
  return res;
}


/*@
assigns \nothing;
ensures \forall real X, real Y; ((((((-60000 <= X) && (X <= 60000)) && ((-10000 <= Y) && (Y <= 10000))) && ((\result.isValid && (\is_finite(X_double) && \is_finite(Y_double))) && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2)))
                                  ==> (\result.value
                                       <==> (first_quadrant(X, Y))))) ;
*/
struct maybeBool first_quadrant_num (double X_double, double Y_double) {
  return first_quadrant_fp (X_double, Y_double, 0x1p-38, 0x1p-40);
}


int main () { return 0; }