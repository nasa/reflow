// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_pred_positive {
logic boolean positive (real X, real Y) =
((X * Y) > 0);
}
*/


/*@
axiomatic fp_pred_positive {
logic boolean positive_fp (double X_double, double Y_double) =
(Dmul(X_double, Y_double) > (double) (0));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures \forall real X, real Y; ((((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double))
                                  ==> ((\result
                                        ==> ((positive(X, Y) && positive_fp(X_double, Y_double))))))) ;
*/
bool positive_tauplus_fp (double X_double, double Y_double, double E_0_double) {
  bool res;
  res = (X_double * Y_double) > E_0_double;
  return res;
}


/*@
assigns \nothing;
ensures \forall real X, real Y; ((((((-60000 <= X) && (X <= 60000)) && ((-10000 <= Y) && (Y <= 10000))) && ((\is_finite(X_double) && \is_finite(Y_double)) && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2)))
                                  ==> ((\result
                                        ==> (positive(X, Y)))))) ;
*/
bool positive_tauplus_num (double X_double, double Y_double) {
  return positive_tauplus_fp (X_double, Y_double, 0x1.4350000000001p-23);
}




/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures \forall real X, real Y; ((((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double))
                                  ==> ((\result
                                        ==> ((! (positive(X, Y)) && ! (positive_fp(X_double, Y_double)))))))) ;
*/
bool positive_tauminus_fp (double X_double, double Y_double, double E_0_double) {
  bool res;
  res = (X_double * Y_double) <= - (E_0_double);
  return res;
}


/*@
assigns \nothing;
ensures \forall real X, real Y; ((((((-60000 <= X) && (X <= 60000)) && ((-10000 <= Y) && (Y <= 10000))) && ((\is_finite(X_double) && \is_finite(Y_double)) && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2)))
                                  ==> ((\result
                                        ==> (! (positive(X, Y))))))) ;
*/
bool positive_tauminus_num (double X_double, double Y_double) {
  return positive_tauminus_fp (X_double, Y_double, 0x1.4350000000001p-23);
}


/*@
axiomatic real_pred_is_zero {
logic boolean is_zero (real X, real Y) =
((X * Y) == 0);
}
*/


/*@
axiomatic fp_pred_is_zero {
logic boolean is_zero_fp (double X_double, double Y_double) =
(Dmul(X_double, Y_double) == (double) (0));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures \forall real X, real Y; ((((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double))
                                  ==> ((\result
                                        ==> ((is_zero(X, Y) && is_zero_fp(X_double, Y_double))))))) ;
*/
bool is_zero_tauplus_fp (double X_double, double Y_double, double E_0_double) {
  bool res;
  res = ((X_double * Y_double) <= - (E_0_double)) && ((X_double * Y_double) >= E_0_double);
  return res;
}


/*@
assigns \nothing;
ensures \forall real X, real Y; ((((((-60000 <= X) && (X <= 60000)) && ((-10000 <= Y) && (Y <= 10000))) && ((\is_finite(X_double) && \is_finite(Y_double)) && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2)))
                                  ==> ((\result
                                        ==> (is_zero(X, Y)))))) ;
*/
bool is_zero_tauplus_num (double X_double, double Y_double) {
  return is_zero_tauplus_fp (X_double, Y_double, 0x1.4350000000001p-23);
}




/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures \forall real X, real Y; ((((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double))
                                  ==> ((\result
                                        ==> ((! (is_zero(X, Y)) && ! (is_zero_fp(X_double, Y_double)))))))) ;
*/
bool is_zero_tauminus_fp (double X_double, double Y_double, double E_0_double) {
  bool res;
  res = ((X_double * Y_double) > E_0_double) || ((X_double * Y_double) < - (E_0_double));
  return res;
}


/*@
assigns \nothing;
ensures \forall real X, real Y; ((((((-60000 <= X) && (X <= 60000)) && ((-10000 <= Y) && (Y <= 10000))) && ((\is_finite(X_double) && \is_finite(Y_double)) && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2)))
                                  ==> ((\result
                                        ==> (! (is_zero(X, Y))))))) ;
*/
bool is_zero_tauminus_num (double X_double, double Y_double) {
  return is_zero_tauminus_fp (X_double, Y_double, 0x1.4350000000001p-23);
}


int main () { return 0; }