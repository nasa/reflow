// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic integer f (real V1, real V2) =
\let DET = (V1 - V2) ;
((DET <= 0) ? (2) : (-2));
}
*/


/*@
axiomatic fp_function_f {
logic integer f_fp (double V1_double, double V2_double) =
\let DET_double = Dsub(V1_double, V2_double) ;
((DET_double <= (double) (0)) ? (2) : (-2));
}
*/


/*@ axiomatic f_trans {
predicate f_stable_paths (real V1, real V2, double V1_double, double V2_double) =
((! (((V1 - V2) <= 0)) && (! ((Dsub(V1_double, V2_double) <= (double) (0))) && (\true && \true))) || (((V1 - V2) <= 0) && ((Dsub(V1_double, V2_double) <= (double) (0)) && (\true && \true))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures (((\is_finite(V1_double) && \is_finite(V2_double)) && \is_finite(E_0_double))
         ==> (equal_fp(\result.value,f_fp(V1_double, V2_double)))) ;

behavior stable_paths:
ensures \forall real V1, real V2; ((\let DET_double = Dsub(V1_double, V2_double);
                                    (\let DET = (V1 - V2);
                                     (\abs(DET_double - DET) <= E_0_double))
                                    ==> (((((\is_finite(V1_double) && \is_finite(V2_double)) && \is_finite(E_0_double)) && \result.isValid)
                                          ==> (f_stable_paths(V1, V2, V1_double, V2_double)))))) ;
*/
struct maybeInt f_fp (double V1_double, double V2_double, double E_0_double) {
  struct maybeInt res;
  double DET_double = (V1_double - V2_double);
  if (DET_double <= - (E_0_double))
  { res = some(2);
  } else { if (DET_double > E_0_double)
           { res = some(-2);
           } else { res = none();
           }
  }
  return res;
}


/*@
assigns \nothing;
ensures (\true
         ==> (\forall real V1, real V2; ((((((-60000 <= V1) && (V1 <= 60000)) && ((-60000 <= V2) && (V2 <= 60000))) && ((\result.isValid && (\is_finite(V1_double) && \is_finite(V2_double))) && (\abs(V1_double - V1) <= ulp_dp(V1)/2 && \abs(V2_double - V2) <= ulp_dp(V2)/2)))
                                          ==> ((\abs((\result.value - f(V1, V2))) <= 0x0p+0)))))) ;
*/
struct maybeInt f_num (double V1_double, double V2_double) {
  return f_fp (V1_double, V2_double, 0x1p-36);
}


/*@
axiomatic real_pred_g {
logic boolean g (real X, real Y) =
(X < 0) ? ((X < 0)) : ((Y < 0));
}
*/


/*@
axiomatic fp_pred_g {
logic boolean g_fp (double X_double, double Y_double) =
(X_double < (double) (0)) ? ((X_double < (double) (0))) : ((Y_double < (double) (0)));
}
*/


/*@ axiomatic g_tauplus_trans {
predicate g_tauplus_stable_paths (real X, real Y, double X_double, double Y_double) =
((! ((X < 0)) && (! ((X_double < (double) (0))) && (\true && \true))) || ((X < 0) && ((X_double < (double) (0)) && (\true && \true))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures \forall real X, real Y; (((\result.isValid && (((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double)))
                                  ==> ((\result.value
                                        ==> ((g(X, Y) && g_fp(X_double, Y_double))))))) ;

behavior stable_paths:
ensures \forall real X, real Y; (((\abs(X_double - X) <= E_0_double && \abs(Y_double - Y) <= E_1_double)
                                  ==> ((((((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double)) && \result.isValid)
                                        ==> (g_tauplus_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeBool g_tauplus_fp (double X_double, double Y_double, double E_0_double, double E_1_double) {
  struct maybeBool res;
  if (X_double < - (E_0_double))
  { res = someBool(X_double < - (E_0_double));
  } else { if (X_double >= E_0_double)
           { res = someBool(Y_double < - (E_1_double));
           } else { res = noneBool();
           }
  }
  return res;
}


/*@
assigns \nothing;
ensures \forall real X, real Y; ((((((-60000 <= X) && (X <= 60000)) && ((-60000 <= Y) && (Y <= 60000))) && ((\result.isValid && (\is_finite(X_double) && \is_finite(Y_double))) && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2)))
                                  ==> ((\result.value
                                        ==> (g(X, Y)))))) ;
*/
struct maybeBool g_tauplus_num (double X_double, double Y_double) {
  return g_tauplus_fp (X_double, Y_double, 0x1p-38, 0x1p-38);
}




/*@ axiomatic g_tauminus_trans {
predicate g_tauminus_stable_paths (real X, real Y, double X_double, double Y_double) =
((! ((X < 0)) && (! ((X_double < (double) (0))) && (\true && \true))) || ((X < 0) && ((X_double < (double) (0)) && (\true && \true))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures \forall real X, real Y; (((\result.isValid && (((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double)))
                                  ==> ((\result.value
                                        ==> ((! (g(X, Y)) && ! (g_fp(X_double, Y_double)))))))) ;

behavior stable_paths:
ensures \forall real X, real Y; (((\abs(X_double - X) <= E_0_double && \abs(Y_double - Y) <= E_1_double)
                                  ==> ((((((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double)) && \result.isValid)
                                        ==> (g_tauminus_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeBool g_tauminus_fp (double X_double, double Y_double, double E_0_double, double E_1_double) {
  struct maybeBool res;
  if (X_double < - (E_0_double))
  { res = someBool(X_double >= E_0_double);
  } else { if (X_double >= E_0_double)
           { res = someBool(Y_double >= E_1_double);
           } else { res = noneBool();
           }
  }
  return res;
}


/*@
assigns \nothing;
ensures \forall real X, real Y; ((((((-60000 <= X) && (X <= 60000)) && ((-60000 <= Y) && (Y <= 60000))) && ((\result.isValid && (\is_finite(X_double) && \is_finite(Y_double))) && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2)))
                                  ==> ((\result.value
                                        ==> (! (g(X, Y))))))) ;
*/
struct maybeBool g_tauminus_num (double X_double, double Y_double) {
  return g_tauminus_fp (X_double, Y_double, 0x1p-38, 0x1p-38);
}


int main () { return 0; }