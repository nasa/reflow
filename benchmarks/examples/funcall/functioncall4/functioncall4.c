// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic integer f (real V1, real V2) =
\let DET = (V1 - V2) ;
((DET <= 0) ? (2) : (-2));
}
*/


/*@
axiomatic fp_function_f {
logic integer f_fp (double V1_double, double V2_double) =
\let DET_double = Dsub(V1_double, V2_double) ;
((DET_double <= (double) (0)) ? (2) : (-2));
}
*/


/*@ axiomatic f_trans {
predicate f_stable_paths (real V1, real V2, double V1_double, double V2_double) =
((! (((V1 - V2) <= 0)) && (! ((Dsub(V1_double, V2_double) <= (double) (0))) && (\true && \true))) || (((V1 - V2) <= 0) && ((Dsub(V1_double, V2_double) <= (double) (0)) && (\true && \true))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures (((\is_finite(V1_double) && \is_finite(V2_double)) && \is_finite(E_0_double))
         ==> (equal_fp(\result.value,f_fp(V1_double, V2_double)))) ;

behavior stable_paths:
ensures \forall real V1, real V2; ((\let DET_double = Dsub(V1_double, V2_double);
                                    (\let DET = (V1 - V2);
                                     (\abs(DET_double - DET) <= E_0_double))
                                    ==> (((((\is_finite(V1_double) && \is_finite(V2_double)) && \is_finite(E_0_double)) && \result.isValid)
                                          ==> (f_stable_paths(V1, V2, V1_double, V2_double)))))) ;
*/
struct maybeInt f_fp (double V1_double, double V2_double, double E_0_double) {
  struct maybeInt res;
  double DET_double = (V1_double - V2_double);
  if (DET_double <= - (E_0_double))
  { res = some(2);
  } else { if (DET_double > E_0_double)
           { res = some(-2);
           } else { res = none();
           }
  }
  return res;
}


/*@
assigns \nothing;
ensures (\true
         ==> (\forall real V1, real V2; ((((((-60000 <= V1) && (V1 <= 60000)) && ((-60000 <= V2) && (V2 <= 60000))) && ((\result.isValid && (\is_finite(V1_double) && \is_finite(V2_double))) && (\abs(V1_double - V1) <= ulp_dp(V1)/2 && \abs(V2_double - V2) <= ulp_dp(V2)/2)))
                                          ==> ((\abs((\result.value - f(V1, V2))) <= 0x0p+0)))))) ;
*/
struct maybeInt f_num (double V1_double, double V2_double) {
  return f_fp (V1_double, V2_double, 0x1p-36);
}


/*@
axiomatic real_function_g {
logic integer g (real X, real Y) =
(X < 0) ? ((1 + f(X, Y))) : ((2 + f(Y, X)));
}
*/


/*@
axiomatic fp_function_g {
logic integer g_fp (double X_double, double Y_double) =
(X_double < (double) (0)) ? (Iadd(1, f_fp(X_double, Y_double))) : (Iadd(2, f_fp(Y_double, X_double)));
}
*/


/*@ axiomatic g_trans {
predicate g_stable_paths (real X, real Y, double X_double, double Y_double) =
(((((! ((X < 0)) && ! (((Y - X) <= 0))) && ((! ((X_double < (double) (0))) && ! ((Dsub(Y_double, X_double) <= (double) (0)))) && (\true && \true))) || ((! ((X < 0)) && ((Y - X) <= 0)) && ((! ((X_double < (double) (0))) && (Dsub(Y_double, X_double) <= (double) (0))) && (\true && \true)))) || (((X < 0) && ! (((X - Y) <= 0))) && (((X_double < (double) (0)) && ! ((Dsub(X_double, Y_double) <= (double) (0)))) && (\true && \true)))) || (((X < 0) && ((X - Y) <= 0)) && (((X_double < (double) (0)) && (Dsub(X_double, Y_double) <= (double) (0))) && (\true && \true))));
}
*/


/*@
requires (((0 <= E_0_double) && (0 <= E_1_double)) && (0 <= E_2_double)) ;
assigns \nothing;

behavior structure:
ensures (((((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double)) && \is_finite(E_2_double))
         ==> (equal_fp(\result.value,g_fp(X_double, Y_double)))) ;

behavior stable_paths:
ensures \forall real X, real Y; ((((((X_double < (double) (0))
                                     ==> (\let DET_double = Dsub(X_double, Y_double);
                                          (\let DET = (X - Y);
                                           (\abs(Dsub(X_double, Y_double) - (X - Y)) <= E_0_double)))) && (! ((X_double < (double) (0)))
                                                                                                           ==> (\let DET_double = Dsub(Y_double, X_double);
                                                                                                                (\let DET = (Y - X);
                                                                                                                 (\abs(Dsub(Y_double, X_double) - (Y - X)) <= E_1_double))))) && \abs(X_double - X) <= E_2_double)
                                  ==> (((((((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double)) && \is_finite(E_2_double)) && \result.isValid)
                                        ==> (g_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeInt g_fp (double X_double, double Y_double, double E_0_double, double E_1_double, double E_2_double) {
  struct maybeInt res;
  struct maybeInt aux_0 = f_fp (X_double, Y_double, E_0_double);
  struct maybeInt aux_1 = f_fp (Y_double, X_double, E_1_double);
  if ((aux_0.isValid) && (aux_1.isValid))
  { if (X_double < - (E_2_double))
    { if (aux_0.isValid)
      { res = some((1 + aux_0.value));
      } else { res = none();
      }
    } else { if (X_double >= E_2_double)
             { if (aux_1.isValid)
               { res = some((2 + aux_1.value));
               } else { res = none();
               }
             } else { res = none();
             }
    }
  } else { res = none();
  }
  return res;
}


/*@
assigns \nothing;
ensures \forall real X, real Y; ((((((-60000 <= X) && (X <= 60000)) && ((-60000 <= Y) && (Y <= 60000))) && ((\result.isValid && (\is_finite(X_double) && \is_finite(Y_double))) && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2)))
                                  ==> ((\abs((\result.value - g(X, Y))) <= 0x0p+0)))) ;
*/
struct maybeInt g_num (double X_double, double Y_double) {
  return g_fp (X_double, Y_double, 0x1p-36, 0x1p-36, 0x1p-38);
}


int main () { return 0; }