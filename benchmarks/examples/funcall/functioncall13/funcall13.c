// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_max_ {
logic real max_ (real a, real b) =
((a - b) >= 0) ? (a) : (b);
}
*/


/*@
axiomatic fp_function_max_ {
logic double max__fp (double a_double, double b_double) =
(Dge(Dsub(a_double, b_double),(double) (0))) ? (a_double) : (b_double);
}
*/


/*@ axiomatic max__trans {
predicate max__stable_paths (real a, real b, double a_double, double b_double) =
((! (((a - b) >= 0)) && (! ((Dge(Dsub(a_double, b_double),(double) (0)))) && (\true && \true))) || (((a - b) >= 0) && ((Dge(Dsub(a_double, b_double),(double) (0))) && (\true && \true))));
}
*/


/*@
requires (Dle((double) (0),E_0_double)) ;
assigns \nothing;

behavior structure:
ensures ((\result.isValid && \is_finite(E_0_double))
         ==> (equal_fp(\result.value,max__fp(a_double, b_double)))) ;

behavior stable_paths:
ensures \forall real a, real b; ((\abs(Dsub(a_double, b_double) - (a - b)) <= E_0_double
                                  ==> (((\is_finite(E_0_double) && \result.isValid)
                                        ==> (max__stable_paths(a, b, a_double, b_double)))))) ;
*/
struct maybeDouble max__fp (double a_double, double b_double, double E_0_double) {
  struct maybeDouble res_double;
  if ((a_double - b_double) >= E_0_double)
  { res_double = someDouble(a_double);
  } else { if ((a_double - b_double) < - (E_0_double))
           { res_double = someDouble(b_double);
           } else { res_double = noneDouble();
           }
  }
  return res_double;
}


/*@
assigns \nothing;
ensures \forall real a, real b; ((((((1 <= a) && (a <= 2)) && ((1 <= b) && (b <= 2))) && ((\result.isValid && (\is_finite(a_double) && \is_finite(b_double))) && (\abs(a_double - a) <= ulp_dp(a)/2 && \abs(b_double - b) <= ulp_dp(b)/2)))
                                  ==> ((\abs((\result.value - max_(a, b))) <= 0x1p-52)))) ;
*/
struct maybeDouble max__num (double a_double, double b_double) {
  return max__fp (a_double, b_double, 0x1.4p-51);
}


/*@
axiomatic real_pred_without_call_conditional_function {
logic boolean without_call_conditional_function (real a, real b) =
((a > 0) || (b > 0));
}
*/


/*@
axiomatic fp_pred_without_call_conditional_function {
logic boolean without_call_conditional_function_fp (double a_double, double b_double) =
((Dgt(a_double,(double) (0))) || (Dgt(b_double,(double) (0))));
}
*/


/*@
requires ((Dle((double) (0),E_0_double)) && (Dle((double) (0),E_1_double))) ;
assigns \nothing;

behavior structure:
ensures \forall real a, real b; (((\result.isValid && (\is_finite(E_0_double) && \is_finite(E_1_double)))
                                  ==> (((\abs(a_double - a) <= E_0_double && \abs(b_double - b) <= E_1_double)
                                        ==> ((\result
                                              ==> ((without_call_conditional_function(a, b) && without_call_conditional_function_fp(a_double, b_double))))))))) ;
*/
bool without_call_conditional_function_tauplus_fp (double a_double, double b_double, double E_0_double, double E_1_double) {
  bool res;
  res = (a_double > E_0_double) || (b_double > E_1_double);
  return res;
}


/*@
assigns \nothing;
ensures \forall real a, real b; ((((((1 <= a) && (a <= 2)) && ((1 <= b) && (b <= 2))) && ((\is_finite(a_double) && \is_finite(b_double)) && (\abs(a_double - a) <= ulp_dp(a)/2 && \abs(b_double - b) <= ulp_dp(b)/2)))
                                  ==> ((\result
                                        ==> (without_call_conditional_function(a, b)))))) ;
*/
bool without_call_conditional_function_tauplus_num (double a_double, double b_double) {
  return without_call_conditional_function_tauplus_fp (a_double, b_double, 0x1p-52, 0x1p-52);
}




/*@
requires ((Dle((double) (0),E_0_double)) && (Dle((double) (0),E_1_double))) ;
assigns \nothing;

behavior structure:
ensures \forall real a, real b; (((\result.isValid && (\is_finite(E_0_double) && \is_finite(E_1_double)))
                                  ==> (((\abs(a_double - a) <= E_0_double && \abs(b_double - b) <= E_1_double)
                                        ==> ((\result
                                              ==> ((! (without_call_conditional_function(a, b)) && ! (without_call_conditional_function_fp(a_double, b_double)))))))))) ;
*/
bool without_call_conditional_function_tauminus_fp (double a_double, double b_double, double E_0_double, double E_1_double) {
  bool res;
  res = (a_double <= - (E_0_double)) && (b_double <= - (E_1_double));
  return res;
}


/*@
assigns \nothing;
ensures \forall real a, real b; ((((((1 <= a) && (a <= 2)) && ((1 <= b) && (b <= 2))) && ((\is_finite(a_double) && \is_finite(b_double)) && (\abs(a_double - a) <= ulp_dp(a)/2 && \abs(b_double - b) <= ulp_dp(b)/2)))
                                  ==> ((\result
                                        ==> (! (without_call_conditional_function(a, b))))))) ;
*/
bool without_call_conditional_function_tauminus_num (double a_double, double b_double) {
  return without_call_conditional_function_tauminus_fp (a_double, b_double, 0x1p-52, 0x1p-52);
}


/*@
axiomatic real_pred_with_call_conditional_function {
logic boolean with_call_conditional_function (real a, real b) =
(max_(a, b) > 0);
}
*/


/*@
axiomatic fp_pred_with_call_conditional_function {
logic boolean with_call_conditional_function_fp (double a_double, double b_double) =
(Dgt(max__fp(a_double, b_double),(double) (0)));
}
*/


/*@
requires ((Dle((double) (0),E_0_double)) && (Dle((double) (0),E_1_double))) ;
assigns \nothing;

behavior structure:
ensures \forall real a, real b; (((\result.isValid && (\is_finite(E_0_double) && \is_finite(E_1_double)))
                                  ==> (((\abs(max__fp(a_double, b_double) - max_(a, b)) <= E_0_double && \abs(Dsub(a_double, b_double) - (a - b)) <= E_1_double)
                                        ==> ((\result.value
                                              ==> ((with_call_conditional_function(a, b) && with_call_conditional_function_fp(a_double, b_double))))))))) ;
*/
struct maybeBool with_call_conditional_function_tauplus_fp (double a_double, double b_double, double E_0_double, double E_1_double) {
  struct maybeBool res;
  struct maybeDouble aux_0_double = max__fp (a_double, b_double, E_1_double);
  if (aux_0_double.isValid)
  { res = aux_0_double.value > E_0_double;
  } else { res = noneBool();
  }
  return res;
}


/*@
assigns \nothing;
ensures \forall real a, real b; ((((((1 <= a) && (a <= 2)) && ((1 <= b) && (b <= 2))) && ((\is_finite(a_double) && \is_finite(b_double)) && (\abs(a_double - a) <= ulp_dp(a)/2 && \abs(b_double - b) <= ulp_dp(b)/2)))
                                  ==> ((\result
                                        ==> (with_call_conditional_function(a, b)))))) ;
*/
bool with_call_conditional_function_tauplus_num (double a_double, double b_double) {
  return with_call_conditional_function_tauplus_fp (a_double, b_double, 0x1p-52, 0x1.4p-51);
}




/*@
requires ((Dle((double) (0),E_0_double)) && (Dle((double) (0),E_1_double))) ;
assigns \nothing;

behavior structure:
ensures \forall real a, real b; (((\result.isValid && (\is_finite(E_0_double) && \is_finite(E_1_double)))
                                  ==> (((\abs(max__fp(a_double, b_double) - max_(a, b)) <= E_0_double && \abs(Dsub(a_double, b_double) - (a - b)) <= E_1_double)
                                        ==> ((\result.value
                                              ==> ((! (with_call_conditional_function(a, b)) && ! (with_call_conditional_function_fp(a_double, b_double)))))))))) ;
*/
struct maybeBool with_call_conditional_function_tauminus_fp (double a_double, double b_double, double E_0_double, double E_1_double) {
  struct maybeBool res;
  struct maybeDouble aux_0_double = max__fp (a_double, b_double, E_1_double);
  if (aux_0_double.isValid)
  { res = aux_0_double.value <= - (E_0_double);
  } else { res = noneBool();
  }
  return res;
}


/*@
assigns \nothing;
ensures \forall real a, real b; ((((((1 <= a) && (a <= 2)) && ((1 <= b) && (b <= 2))) && ((\is_finite(a_double) && \is_finite(b_double)) && (\abs(a_double - a) <= ulp_dp(a)/2 && \abs(b_double - b) <= ulp_dp(b)/2)))
                                  ==> ((\result
                                        ==> (! (with_call_conditional_function(a, b))))))) ;
*/
bool with_call_conditional_function_tauminus_num (double a_double, double b_double) {
  return with_call_conditional_function_tauminus_fp (a_double, b_double, 0x1p-52, 0x1.4p-51);
}


int main () { return 0; }