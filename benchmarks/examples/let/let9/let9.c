// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_sign {
logic integer sign (real x) =
(x >= 0) ? (1) : (-1);
}
*/


/*@
axiomatic fp_function_sign {
logic integer sign_fp (double x_double) =
(x_double >= (double) (0)) ? (1) : (-1);
}
*/


/*@ axiomatic sign_trans {
predicate sign_stable_paths (real x, double x_double) =
((! ((x >= 0)) && (! ((x_double >= (double) (0))) && (\true && \true))) || ((x >= 0) && ((x_double >= (double) (0)) && (\true && \true))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures ((\is_finite(x_double) && \is_finite(E_0_double))
         ==> (equal_fp(\result.value,sign_fp(x_double)))) ;

behavior stable_paths:
ensures \forall real x; ((\abs(x_double - x) <= E_0_double
                          ==> ((((\is_finite(x_double) && \is_finite(E_0_double)) && \result.isValid)
                                ==> (sign_stable_paths(x, x_double)))))) ;
*/
struct maybeInt sign_fp (double x_double, double E_0_double) {
  struct maybeInt res;
  if (x_double >= E_0_double)
  { res = some(1);
  } else { if (x_double < - (E_0_double))
           { res = some(-1);
           } else { res = none();
           }
  }
  return res;
}


/*@
assigns \nothing;
ensures \forall real x; (((((1 <= x) && (x <= 100)) && ((\result.isValid && \is_finite(x_double)) && \abs(x_double - x) <= ulp_dp(x)/2))
                          ==> ((\abs((\result.value - sign(x))) <= 0x0p+0)))) ;
*/
struct maybeInt sign_num (double x_double) {
  return sign_fp (x_double, 0x1p-47);
}


/*@
axiomatic real_function_max_ {
logic real max_ (real a, real b) =
((a - b) < 0) ? (b) : (a);
}
*/


/*@
axiomatic fp_function_max_ {
logic double max__fp (double a_double, double b_double) =
(Dsub(a_double, b_double) < (double) (0)) ? (b_double) : (a_double);
}
*/


/*@ axiomatic max__trans {
predicate max__stable_paths (real a, real b, double a_double, double b_double) =
((! (((a - b) < 0)) && (! ((Dsub(a_double, b_double) < (double) (0))) && (\true && \true))) || (((a - b) < 0) && ((Dsub(a_double, b_double) < (double) (0)) && (\true && \true))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures (((\is_finite(a_double) && \is_finite(b_double)) && \is_finite(E_0_double))
         ==> (equal_fp(\result.value,max__fp(a_double, b_double)))) ;

behavior stable_paths:
ensures \forall real a, real b; ((\abs(Dsub(a_double, b_double) - (a - b)) <= E_0_double
                                  ==> (((((\is_finite(a_double) && \is_finite(b_double)) && \is_finite(E_0_double)) && \result.isValid)
                                        ==> (max__stable_paths(a, b, a_double, b_double)))))) ;
*/
struct maybeDouble max__fp (double a_double, double b_double, double E_0_double) {
  struct maybeDouble res_double;
  if ((a_double - b_double) < - (E_0_double))
  { res_double = someDouble(b_double);
  } else { if ((a_double - b_double) >= E_0_double)
           { res_double = someDouble(a_double);
           } else { res_double = noneDouble();
           }
  }
  return res_double;
}


/*@
assigns \nothing;
ensures \forall real a, real b; ((((((1 <= a) && (a <= 100)) && ((1 <= b) && (b <= 100))) && ((\result.isValid && (\is_finite(a_double) && \is_finite(b_double))) && (\abs(a_double - a) <= ulp_dp(a)/2 && \abs(b_double - b) <= ulp_dp(b)/2)))
                                  ==> ((\abs((\result.value - max_(a, b))) <= 0x1p-47)))) ;
*/
struct maybeDouble max__num (double a_double, double b_double) {
  return max__fp (a_double, b_double, 0x1.8p-46);
}


/*@
axiomatic real_function_min_ {
logic real min_ (real a, real b) =
((a - b) > 0) ? (b) : (a);
}
*/


/*@
axiomatic fp_function_min_ {
logic double min__fp (double a_double, double b_double) =
(Dsub(a_double, b_double) > (double) (0)) ? (b_double) : (a_double);
}
*/


/*@ axiomatic min__trans {
predicate min__stable_paths (real a, real b, double a_double, double b_double) =
((! (((a - b) > 0)) && (! ((Dsub(a_double, b_double) > (double) (0))) && (\true && \true))) || (((a - b) > 0) && ((Dsub(a_double, b_double) > (double) (0)) && (\true && \true))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures (((\is_finite(a_double) && \is_finite(b_double)) && \is_finite(E_0_double))
         ==> (equal_fp(\result.value,min__fp(a_double, b_double)))) ;

behavior stable_paths:
ensures \forall real a, real b; ((\abs(Dsub(a_double, b_double) - (a - b)) <= E_0_double
                                  ==> (((((\is_finite(a_double) && \is_finite(b_double)) && \is_finite(E_0_double)) && \result.isValid)
                                        ==> (min__stable_paths(a, b, a_double, b_double)))))) ;
*/
struct maybeDouble min__fp (double a_double, double b_double, double E_0_double) {
  struct maybeDouble res_double;
  if ((a_double - b_double) > E_0_double)
  { res_double = someDouble(b_double);
  } else { if ((a_double - b_double) <= - (E_0_double))
           { res_double = someDouble(a_double);
           } else { res_double = noneDouble();
           }
  }
  return res_double;
}


/*@
assigns \nothing;
ensures \forall real a, real b; ((((((1 <= a) && (a <= 100)) && ((1 <= b) && (b <= 100))) && ((\result.isValid && (\is_finite(a_double) && \is_finite(b_double))) && (\abs(a_double - a) <= ulp_dp(a)/2 && \abs(b_double - b) <= ulp_dp(b)/2)))
                                  ==> ((\abs((\result.value - min_(a, b))) <= 0x1p-47)))) ;
*/
struct maybeDouble min__num (double a_double, double b_double) {
  return min__fp (a_double, b_double, 0x1.8p-46);
}


/*@
axiomatic real_function_Theta_H_neg {
logic real Theta_H_neg (real sz, real nzvz, real H) =
(((-(sign(nzvz)) * H) - sz) / nzvz);
}
*/


/*@
axiomatic fp_function_Theta_H_neg {
logic double Theta_H_neg_fp (double sz_double, double nzvz_double, double H_double) =
Ddiv(Dsub(Dmul((double) (Ineg(sign_fp(nzvz_double))), H_double), sz_double), nzvz_double);
}
*/


/*@ axiomatic Theta_H_neg_trans {
predicate Theta_H_neg_stable_paths (real sz, real nzvz, real H, double sz_double, double nzvz_double, double H_double) =
((! ((nzvz >= 0)) && (! ((nzvz_double >= (double) (0))) && ((nzvz != 0) && (nzvz_double != (double) (0))))) || ((nzvz >= 0) && ((nzvz_double >= (double) (0)) && ((nzvz != 0) && (nzvz_double != (double) (0))))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures ((((\is_finite(sz_double) && \is_finite(nzvz_double)) && \is_finite(H_double)) && \is_finite(E_0_double))
         ==> (equal_fp(\result.value,Theta_H_neg_fp(sz_double, nzvz_double, H_double)))) ;

behavior stable_paths:
ensures \forall real sz, real nzvz, real H; ((\abs(nzvz_double - nzvz) <= E_0_double
                                              ==> ((((((\is_finite(sz_double) && \is_finite(nzvz_double)) && \is_finite(H_double)) && \is_finite(E_0_double)) && \result.isValid)
                                                    ==> (Theta_H_neg_stable_paths(sz, nzvz, H, sz_double, nzvz_double, H_double)))))) ;
*/
struct maybeDouble Theta_H_neg_fp (double sz_double, double nzvz_double, double H_double, double E_0_double) {
  struct maybeDouble res_double;
  struct maybeInt aux_0 = sign_fp (nzvz_double, E_0_double);
  if (aux_0.isValid)
  { res_double = someDouble(((((double)(- (aux_0.value)) * H_double) - sz_double) / nzvz_double));
  } else { res_double = noneDouble();
  }
  return res_double;
}


/*@
assigns \nothing;
ensures \forall real sz, real nzvz, real H; (((((((1 <= sz) && (sz <= 2)) && ((1 <= nzvz) && (nzvz <= 2))) && ((1 <= H) && (H <= 2))) && ((\result.isValid && ((\is_finite(sz_double) && \is_finite(nzvz_double)) && \is_finite(H_double))) && ((\abs(sz_double - sz) <= ulp_dp(sz)/2 && \abs(nzvz_double - nzvz) <= ulp_dp(nzvz)/2) && \abs(H_double - H) <= ulp_dp(H)/2)))
                                              ==> ((\abs((\result.value - Theta_H_neg(sz, nzvz, H))) <= 0x1.0000000000002p-48)))) ;
*/
struct maybeDouble Theta_H_neg_num (double sz_double, double nzvz_double, double H_double) {
  return Theta_H_neg_fp (sz_double, nzvz_double, H_double, 0x1p-52);
}


/*@
axiomatic real_function_Theta_H_pos {
logic real Theta_H_pos (real sz, real nzvz, real H) =
(((sign(nzvz) * H) - sz) / nzvz);
}
*/


/*@
axiomatic fp_function_Theta_H_pos {
logic double Theta_H_pos_fp (double sz_double, double nzvz_double, double H_double) =
Ddiv(Dsub(Dmul((double) (sign_fp(nzvz_double)), H_double), sz_double), nzvz_double);
}
*/


/*@ axiomatic Theta_H_pos_trans {
predicate Theta_H_pos_stable_paths (real sz, real nzvz, real H, double sz_double, double nzvz_double, double H_double) =
((! ((nzvz >= 0)) && (! ((nzvz_double >= (double) (0))) && ((nzvz != 0) && (nzvz_double != (double) (0))))) || ((nzvz >= 0) && ((nzvz_double >= (double) (0)) && ((nzvz != 0) && (nzvz_double != (double) (0))))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures ((((\is_finite(sz_double) && \is_finite(nzvz_double)) && \is_finite(H_double)) && \is_finite(E_0_double))
         ==> (equal_fp(\result.value,Theta_H_pos_fp(sz_double, nzvz_double, H_double)))) ;

behavior stable_paths:
ensures \forall real sz, real nzvz, real H; ((\abs(nzvz_double - nzvz) <= E_0_double
                                              ==> ((((((\is_finite(sz_double) && \is_finite(nzvz_double)) && \is_finite(H_double)) && \is_finite(E_0_double)) && \result.isValid)
                                                    ==> (Theta_H_pos_stable_paths(sz, nzvz, H, sz_double, nzvz_double, H_double)))))) ;
*/
struct maybeDouble Theta_H_pos_fp (double sz_double, double nzvz_double, double H_double, double E_0_double) {
  struct maybeDouble res_double;
  struct maybeInt aux_0 = sign_fp (nzvz_double, E_0_double);
  if (aux_0.isValid)
  { res_double = someDouble(((((double)(aux_0.value) * H_double) - sz_double) / nzvz_double));
  } else { res_double = noneDouble();
  }
  return res_double;
}


/*@
assigns \nothing;
ensures \forall real sz, real nzvz, real H; (((((((1 <= sz) && (sz <= 2)) && ((1 <= nzvz) && (nzvz <= 2))) && ((1 <= H) && (H <= 2))) && ((\result.isValid && ((\is_finite(sz_double) && \is_finite(nzvz_double)) && \is_finite(H_double))) && ((\abs(sz_double - sz) <= ulp_dp(sz)/2 && \abs(nzvz_double - nzvz) <= ulp_dp(nzvz)/2) && \abs(H_double - H) <= ulp_dp(H)/2)))
                                              ==> ((\abs((\result.value - Theta_H_pos(sz, nzvz, H))) <= 0x1.0000000000002p-48)))) ;
*/
struct maybeDouble Theta_H_pos_num (double sz_double, double nzvz_double, double H_double) {
  return Theta_H_pos_fp (sz_double, nzvz_double, H_double, 0x1p-52);
}


/*@
axiomatic real_function_coalt_exit {
logic real coalt_exit (real sz, real nzvz, real ZTHR) =
Theta_H_pos(sz, nzvz, ZTHR);
}
*/


/*@
axiomatic fp_function_coalt_exit {
logic double coalt_exit_fp (double sz_double, double nzvz_double, double ZTHR_double) =
Theta_H_pos_fp(sz_double, nzvz_double, ZTHR_double);
}
*/


/*@ axiomatic coalt_exit_trans {
predicate coalt_exit_stable_paths (real sz, real nzvz, real ZTHR, double sz_double, double nzvz_double, double ZTHR_double) =
((! ((nzvz >= 0)) && (! ((nzvz_double >= (double) (0))) && ((nzvz != 0) && (nzvz_double != (double) (0))))) || ((nzvz >= 0) && ((nzvz_double >= (double) (0)) && ((nzvz != 0) && (nzvz_double != (double) (0))))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures ((((\is_finite(sz_double) && \is_finite(nzvz_double)) && \is_finite(ZTHR_double)) && \is_finite(E_0_double))
         ==> (equal_fp(\result.value,coalt_exit_fp(sz_double, nzvz_double, ZTHR_double)))) ;

behavior stable_paths:
ensures \forall real sz, real nzvz, real ZTHR; ((\abs(nzvz_double - nzvz) <= E_0_double
                                                 ==> ((((((\is_finite(sz_double) && \is_finite(nzvz_double)) && \is_finite(ZTHR_double)) && \is_finite(E_0_double)) && \result.isValid)
                                                       ==> (coalt_exit_stable_paths(sz, nzvz, ZTHR, sz_double, nzvz_double, ZTHR_double)))))) ;
*/
struct maybeDouble coalt_exit_fp (double sz_double, double nzvz_double, double ZTHR_double, double E_0_double) {
  struct maybeDouble res_double;
  res_double = someDouble(Theta_H_pos_fp (sz_double, nzvz_double, ZTHR_double, E_0_double).value);
  return res_double;
}


/*@
assigns \nothing;
ensures \forall real sz, real nzvz, real ZTHR; (((((((1 <= sz) && (sz <= 2)) && ((1 <= nzvz) && (nzvz <= 2))) && ((1 <= ZTHR) && (ZTHR <= 3))) && ((\result.isValid && ((\is_finite(sz_double) && \is_finite(nzvz_double)) && \is_finite(ZTHR_double))) && ((\abs(sz_double - sz) <= ulp_dp(sz)/2 && \abs(nzvz_double - nzvz) <= ulp_dp(nzvz)/2) && \abs(ZTHR_double - ZTHR) <= ulp_dp(ZTHR)/2)))
                                                 ==> ((\abs((\result.value - coalt_exit(sz, nzvz, ZTHR))) <= 0x1.1000000000002p-48)))) ;
*/
struct maybeDouble coalt_exit_num (double sz_double, double nzvz_double, double ZTHR_double) {
  return coalt_exit_fp (sz_double, nzvz_double, ZTHR_double, 0x1p-52);
}


/*@
axiomatic real_function_coalt_entry {
logic real coalt_entry (real sz, real nzvz, real TCOA, real ZTHR) =
\let Z_COA = (\abs(nzvz) * TCOA) ;
(((ZTHR - Z_COA) <= 0) ? (Theta_H_neg(sz, nzvz, Z_COA)) : (Theta_H_neg(sz, nzvz, ZTHR)));
}
*/


/*@
axiomatic fp_function_coalt_entry {
logic double coalt_entry_fp (double sz_double, double nzvz_double, double TCOA_double, double ZTHR_double) =
\let Z_COA_double = Dmul(Dabs(nzvz_double), TCOA_double) ;
((Dsub(ZTHR_double, Z_COA_double) <= (double) (0)) ? (Theta_H_neg_fp(sz_double, nzvz_double, Z_COA_double)) : (Theta_H_neg_fp(sz_double, nzvz_double, ZTHR_double)));
}
*/


/*@ axiomatic coalt_entry_trans {
predicate coalt_entry_stable_paths (real sz, real nzvz, real TCOA, real ZTHR, double sz_double, double nzvz_double, double TCOA_double, double ZTHR_double) =
(((((! (((ZTHR - (\abs(nzvz) * TCOA)) <= 0)) && ! ((nzvz >= 0))) && ((! ((Dsub(ZTHR_double, Dmul(Dabs(nzvz_double), TCOA_double)) <= (double) (0))) && ! ((nzvz_double >= (double) (0)))) && ((nzvz != 0) && (nzvz_double != (double) (0))))) || ((! (((ZTHR - (\abs(nzvz) * TCOA)) <= 0)) && (nzvz >= 0)) && ((! ((Dsub(ZTHR_double, Dmul(Dabs(nzvz_double), TCOA_double)) <= (double) (0))) && (nzvz_double >= (double) (0))) && ((nzvz != 0) && (nzvz_double != (double) (0)))))) || ((((ZTHR - (\abs(nzvz) * TCOA)) <= 0) && ! ((nzvz >= 0))) && (((Dsub(ZTHR_double, Dmul(Dabs(nzvz_double), TCOA_double)) <= (double) (0)) && ! ((nzvz_double >= (double) (0)))) && ((nzvz != 0) && (nzvz_double != (double) (0)))))) || ((((ZTHR - (\abs(nzvz) * TCOA)) <= 0) && (nzvz >= 0)) && (((Dsub(ZTHR_double, Dmul(Dabs(nzvz_double), TCOA_double)) <= (double) (0)) && (nzvz_double >= (double) (0))) && ((nzvz != 0) && (nzvz_double != (double) (0))))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures ((((((\is_finite(sz_double) && \is_finite(nzvz_double)) && \is_finite(TCOA_double)) && \is_finite(ZTHR_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double))
         ==> (equal_fp(\result.value,coalt_entry_fp(sz_double, nzvz_double, TCOA_double, ZTHR_double)))) ;

behavior stable_paths:
ensures \forall real sz, real nzvz, real TCOA, real ZTHR; (((((Dsub(ZTHR_double, Z_COA_double) <= (double) (0))
                                                              ==> (\abs(nzvz_double - nzvz) <= E_0_double)) && \let Z_COA_double = Dmul(Dabs(nzvz_double), TCOA_double);
                                                                                                               (\let Z_COA = (\abs(nzvz) * TCOA);
                                                                                                                (\abs(Dsub(ZTHR_double, Z_COA_double) - (ZTHR - Z_COA)) <= E_1_double)))
                                                            ==> ((((((((\is_finite(sz_double) && \is_finite(nzvz_double)) && \is_finite(TCOA_double)) && \is_finite(ZTHR_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double)) && \result.isValid)
                                                                  ==> (coalt_entry_stable_paths(sz, nzvz, TCOA, ZTHR, sz_double, nzvz_double, TCOA_double, ZTHR_double)))))) ;
*/
struct maybeDouble coalt_entry_fp (double sz_double, double nzvz_double, double TCOA_double, double ZTHR_double, double E_0_double, double E_1_double) {
  struct maybeDouble res_double;
  double Z_COA_double = (fabs(nzvz_double) * TCOA_double);
  struct maybeDouble aux_0_double = Theta_H_neg_fp (sz_double, nzvz_double, Z_COA_double, E_0_double);
  struct maybeDouble aux_1_double = Theta_H_neg_fp (sz_double, nzvz_double, ZTHR_double, E_0_double);
  if ((aux_0_double.isValid) && (aux_1_double.isValid))
  { if ((ZTHR_double - Z_COA_double) <= - (E_1_double))
    { res_double = someDouble(aux_0_double.value);
    } else { if ((ZTHR_double - Z_COA_double) > E_1_double)
             { res_double = someDouble(aux_1_double.value);
             } else { res_double = noneDouble();
             }
    }
  } else { res_double = noneDouble();
  }
  return res_double;
}


/*@
assigns \nothing;
ensures (\true
         ==> (\forall real sz, real nzvz, real TCOA, real ZTHR; ((((((((1 <= sz) && (sz <= 2)) && ((1 <= nzvz) && (nzvz <= 2))) && ((2 <= TCOA) && (TCOA <= 3))) && ((1 <= ZTHR) && (ZTHR <= 3))) && ((\result.isValid && (((\is_finite(sz_double) && \is_finite(nzvz_double)) && \is_finite(TCOA_double)) && \is_finite(ZTHR_double))) && (((\abs(sz_double - sz) <= ulp_dp(sz)/2 && \abs(nzvz_double - nzvz) <= ulp_dp(nzvz)/2) && \abs(TCOA_double - TCOA) <= ulp_dp(TCOA)/2) && \abs(ZTHR_double - ZTHR) <= ulp_dp(ZTHR)/2)))
                                                                  ==> ((\abs((\result.value - coalt_entry(sz, nzvz, TCOA, ZTHR))) <= 0x1.4000000000004p-47)))))) ;
*/
struct maybeDouble coalt_entry_num (double sz_double, double nzvz_double, double TCOA_double, double ZTHR_double) {
  return coalt_entry_fp (sz_double, nzvz_double, TCOA_double, ZTHR_double, 0x1p-52, 0x1.4000000000001p-49);
}


/*@
axiomatic real_function_vertical_WCV_exit_minus_entry {
logic real vertical_WCV_exit_minus_entry (real B, real T, real sz, real vz, real TCOA, real ZTHR) =
((vz != 0))
? \let centry = coalt_entry(sz, vz, TCOA, ZTHR) ;
  \let cexit = coalt_exit(sz, vz, ZTHR) ;
  (((T - centry) < 0) ? ((B - T)) : ((min_(T, cexit) - max_(B, centry)))) :
(((\abs(sz) - ZTHR) <= 0))
? (T - B) :
(B - T);
}
*/


/*@
axiomatic fp_function_vertical_WCV_exit_minus_entry {
logic double vertical_WCV_exit_minus_entry_fp (double B_double, double T_double, double sz_double, double vz_double, double TCOA_double, double ZTHR_double) =
((vz_double != (double) (0)))
? \let centry_double = coalt_entry_fp(sz_double, vz_double, TCOA_double, ZTHR_double) ;
  \let cexit_double = coalt_exit_fp(sz_double, vz_double, ZTHR_double) ;
  ((Dsub(T_double, centry_double) < (double) (0)) ? (Dsub(B_double, T_double)) : (Dsub(min__fp(T_double, cexit_double), max__fp(B_double, centry_double)))) :
((Dsub(Dabs(sz_double), ZTHR_double) <= (double) (0)))
? Dsub(T_double, B_double) :
Dsub(B_double, T_double);
}
*/


/*@ axiomatic vertical_WCV_exit_minus_entry_trans {
predicate vertical_WCV_exit_minus_entry_stable_paths (real B, real T, real sz, real vz, real TCOA, real ZTHR, double B_double, double T_double, double sz_double, double vz_double, double TCOA_double, double ZTHR_double) =
((((((((((((((! (((\abs(sz) - ZTHR) <= 0)) && ! ((vz != 0))) && ((! ((Dsub(Dabs(sz_double), ZTHR_double) <= (double) (0))) && ! ((vz_double != (double) (0)))) && (\true && \true))) || (((vz != 0) && (! (((T - coalt_entry(sz, vz, TCOA, ZTHR)) < 0)) && (! (((T - coalt_exit(sz, vz, ZTHR)) > 0)) && ! (((B - coalt_entry(sz, vz, TCOA, ZTHR)) < 0))))) && (((vz_double != (double) (0)) && (! ((Dsub(T_double, coalt_entry_fp(sz_double, vz_double, TCOA_double, ZTHR_double)) < (double) (0))) && (! ((Dsub(T_double, coalt_exit_fp(sz_double, vz_double, ZTHR_double)) > (double) (0))) && ! ((Dsub(B_double, coalt_entry_fp(sz_double, vz_double, TCOA_double, ZTHR_double)) < (double) (0)))))) && (\true && \true)))) || (((vz != 0) && (! (((T - coalt_entry(sz, vz, TCOA, ZTHR)) < 0)) && (! (((T - coalt_exit(sz, vz, ZTHR)) > 0)) && ((B - coalt_entry(sz, vz, TCOA, ZTHR)) < 0)))) && (((vz_double != (double) (0)) && (! ((Dsub(T_double, coalt_entry_fp(sz_double, vz_double, TCOA_double, ZTHR_double)) < (double) (0))) && (! ((Dsub(T_double, coalt_exit_fp(sz_double, vz_double, ZTHR_double)) > (double) (0))) && (Dsub(B_double, coalt_entry_fp(sz_double, vz_double, TCOA_double, ZTHR_double)) < (double) (0))))) && (\true && \true)))) || (((vz != 0) && (! (((T - coalt_entry(sz, vz, TCOA, ZTHR)) < 0)) && (((T - coalt_exit(sz, vz, ZTHR)) > 0) && ! (((B - coalt_entry(sz, vz, TCOA, ZTHR)) < 0))))) && (((vz_double != (double) (0)) && (! ((Dsub(T_double, coalt_entry_fp(sz_double, vz_double, TCOA_double, ZTHR_double)) < (double) (0))) && ((Dsub(T_double, coalt_exit_fp(sz_double, vz_double, ZTHR_double)) > (double) (0)) && ! ((Dsub(B_double, coalt_entry_fp(sz_double, vz_double, TCOA_double, ZTHR_double)) < (double) (0)))))) && (\true && \true)))) || (((vz != 0) && (! (((T - coalt_entry(sz, vz, TCOA, ZTHR)) < 0)) && (((T - coalt_exit(sz, vz, ZTHR)) > 0) && ((B - coalt_entry(sz, vz, TCOA, ZTHR)) < 0)))) && (((vz_double != (double) (0)) && (! ((Dsub(T_double, coalt_entry_fp(sz_double, vz_double, TCOA_double, ZTHR_double)) < (double) (0))) && ((Dsub(T_double, coalt_exit_fp(sz_double, vz_double, ZTHR_double)) > (double) (0)) && (Dsub(B_double, coalt_entry_fp(sz_double, vz_double, TCOA_double, ZTHR_double)) < (double) (0))))) && (\true && \true)))) || (((vz != 0) && (! (((ZTHR - (\abs(vz) * TCOA)) <= 0)) && ! ((vz >= 0)))) && (((vz_double != (double) (0)) && (! ((Dsub(ZTHR_double, Dmul(Dabs(vz_double), TCOA_double)) <= (double) (0))) && ! ((vz_double >= (double) (0))))) && ((vz != 0) && (vz_double != (double) (0)))))) || (((vz != 0) && (! (((ZTHR - (\abs(vz) * TCOA)) <= 0)) && (vz >= 0))) && (((vz_double != (double) (0)) && (! ((Dsub(ZTHR_double, Dmul(Dabs(vz_double), TCOA_double)) <= (double) (0))) && (vz_double >= (double) (0)))) && ((vz != 0) && (vz_double != (double) (0)))))) || (((vz != 0) && (((ZTHR - (\abs(vz) * TCOA)) <= 0) && ! ((vz >= 0)))) && (((vz_double != (double) (0)) && ((Dsub(ZTHR_double, Dmul(Dabs(vz_double), TCOA_double)) <= (double) (0)) && ! ((vz_double >= (double) (0))))) && ((vz != 0) && (vz_double != (double) (0)))))) || (((vz != 0) && (((ZTHR - (\abs(vz) * TCOA)) <= 0) && (vz >= 0))) && (((vz_double != (double) (0)) && ((Dsub(ZTHR_double, Dmul(Dabs(vz_double), TCOA_double)) <= (double) (0)) && (vz_double >= (double) (0)))) && ((vz != 0) && (vz_double != (double) (0)))))) || (((vz != 0) && ! ((vz >= 0))) && (((vz_double != (double) (0)) && ! ((vz_double >= (double) (0)))) && ((vz != 0) && (vz_double != (double) (0)))))) || (((vz != 0) && ((T - coalt_entry(sz, vz, TCOA, ZTHR)) < 0)) && (((vz_double != (double) (0)) && (Dsub(T_double, coalt_entry_fp(sz_double, vz_double, TCOA_double, ZTHR_double)) < (double) (0))) && (\true && \true)))) || (((vz != 0) && (vz >= 0)) && (((vz_double != (double) (0)) && (vz_double >= (double) (0))) && ((vz != 0) && (vz_double != (double) (0)))))) || ((((\abs(sz) - ZTHR) <= 0) && ! ((vz != 0))) && (((Dsub(Dabs(sz_double), ZTHR_double) <= (double) (0)) && ! ((vz_double != (double) (0)))) && (\true && \true))));
}
*/


/*@
requires ((((((0 <= E_0_double) && (0 <= E_1_double)) && (0 <= E_2_double)) && (0 <= E_3_double)) && (0 <= E_4_double)) && (0 <= E_5_double)) ;
assigns \nothing;

behavior structure:
ensures ((((((((((((\is_finite(B_double) && \is_finite(T_double)) && \is_finite(sz_double)) && \is_finite(vz_double)) && \is_finite(TCOA_double)) && \is_finite(ZTHR_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double)) && \is_finite(E_2_double)) && \is_finite(E_3_double)) && \is_finite(E_4_double)) && \is_finite(E_5_double))
         ==> (equal_fp(\result.value,vertical_WCV_exit_minus_entry_fp(B_double, T_double, sz_double, vz_double, TCOA_double, ZTHR_double)))) ;

behavior stable_paths:
ensures \forall real B, real T, real sz, real vz, real TCOA, real ZTHR; (((((((\abs(vz_double - vz) <= E_0_double && \let Z_COA_double = Dmul(Dabs(vz_double), TCOA_double);
                                                                                                                     (\let Z_COA = (\abs(vz) * TCOA);
                                                                                                                      (\abs(Dsub(ZTHR_double, Dmul(Dabs(vz_double), TCOA_double)) - (ZTHR - (\abs(vz) * TCOA))) <= E_1_double))) && (! ((Dsub(T_double, centry_double) < (double) (0)))
                                                                                                                                                                                                                                     ==> (\let cexit_double = coalt_exit_fp(sz_double, vz_double, ZTHR_double);
                                                                                                                                                                                                                                          (\let cexit = coalt_exit(sz, vz, ZTHR);
                                                                                                                                                                                                                                           (\abs(Dsub(T_double, cexit_double) - (T - cexit)) <= E_2_double))))) && (! ((Dsub(T_double, centry_double) < (double) (0)))
                                                                                                                                                                                                                                                                                                                    ==> (\let centry_double = coalt_entry_fp(sz_double, vz_double, TCOA_double, ZTHR_double);
                                                                                                                                                                                                                                                                                                                         (\let centry = coalt_entry(sz, vz, TCOA, ZTHR);
                                                                                                                                                                                                                                                                                                                          (\abs(Dsub(B_double, centry_double) - (B - centry)) <= E_3_double))))) && \let centry_double = coalt_entry_fp(sz_double, vz_double, TCOA_double, ZTHR_double);
                                                                                                                                                                                                                                                                                                                                                                                                    (\let centry = coalt_entry(sz, vz, TCOA, ZTHR);
                                                                                                                                                                                                                                                                                                                                                                                                     (\abs(Dsub(T_double, centry_double) - (T - centry)) <= E_4_double))) && \abs(Dsub(Dabs(sz_double), ZTHR_double) - (\abs(sz) - ZTHR)) <= E_5_double)
                                                                          ==> ((((((((((((((\is_finite(B_double) && \is_finite(T_double)) && \is_finite(sz_double)) && \is_finite(vz_double)) && \is_finite(TCOA_double)) && \is_finite(ZTHR_double)) && \is_finite(E_0_double)) && \is_finite(E_1_double)) && \is_finite(E_2_double)) && \is_finite(E_3_double)) && \is_finite(E_4_double)) && \is_finite(E_5_double)) && \result.isValid)
                                                                                ==> (vertical_WCV_exit_minus_entry_stable_paths(B, T, sz, vz, TCOA, ZTHR, B_double, T_double, sz_double, vz_double, TCOA_double, ZTHR_double)))))) ;
*/
struct maybeDouble vertical_WCV_exit_minus_entry_fp (double B_double, double T_double, double sz_double, double vz_double, double TCOA_double, double ZTHR_double, double E_0_double, double E_1_double, double E_2_double, double E_3_double, double E_4_double, double E_5_double) {
  struct maybeDouble res_double;
  struct maybeDouble aux_0_double = coalt_entry_fp (sz_double, vz_double, TCOA_double, ZTHR_double, E_0_double, E_1_double);
  struct maybeDouble aux_1_double = coalt_exit_fp (sz_double, vz_double, ZTHR_double, E_0_double);
  struct maybeDouble aux_2_double = min__fp (T_double, cexit_double, E_2_double);
  struct maybeDouble aux_3_double = max__fp (B_double, centry_double, E_3_double);
  if ((((aux_0_double.isValid) && (aux_1_double.isValid)) && (aux_2_double.isValid)) && (aux_3_double.isValid))
  { if ((vz_double > E_0_double) || (vz_double < - (E_0_double)))
    { if (aux_0_double.isValid)
      { double centry_double = aux_0_double.value;
        if (aux_1_double.isValid)
        { double cexit_double = aux_1_double.value;
          if ((aux_2_double.isValid) && (aux_3_double.isValid))
          { if ((T_double - centry_double) < - (E_4_double))
            { res_double = someDouble((B_double - T_double));
            } else { if ((T_double - centry_double) >= E_4_double)
                     { if ((aux_2_double.isValid) && (aux_3_double.isValid))
                       { res_double = someDouble((aux_2_double.value - aux_3_double.value));
                       } else { res_double = noneDouble();
                       }
                     } else { res_double = noneDouble();
                     }
            }
          } else { res_double = noneDouble();
          }
        } else { res_double = noneDouble();
        }
      } else { res_double = noneDouble();
      };
    }
    else if (((fabs(sz_double) - ZTHR_double) <= - (E_5_double)) && ((vz_double <= - (E_0_double)) && (vz_double >= E_0_double)))
    { res_double = someDouble((T_double - B_double));; }
    else if (((fabs(sz_double) - ZTHR_double) > E_5_double) && ((vz_double <= - (E_0_double)) && (vz_double >= E_0_double)))
    { res_double = someDouble((B_double - T_double));; }
    else { res_double = noneDouble();
    }
  } else { res_double = noneDouble();
  }
  return res_double;
}


/*@
assigns \nothing;
ensures (\true
         ==> (\forall real B, real T, real sz, real vz, real TCOA, real ZTHR; ((((((((((1 <= B) && (B <= 10)) && ((1 <= T) && (T <= 10))) && ((1 <= sz) && (sz <= 2))) && ((1 <= vz) && (vz <= 2))) && ((2 <= TCOA) && (TCOA <= 3))) && ((2 <= ZTHR) && (ZTHR <= 3))) && ((\result.isValid && (((((\is_finite(B_double) && \is_finite(T_double)) && \is_finite(sz_double)) && \is_finite(vz_double)) && \is_finite(TCOA_double)) && \is_finite(ZTHR_double))) && (((((\abs(B_double - B) <= ulp_dp(B)/2 && \abs(T_double - T) <= ulp_dp(T)/2) && \abs(sz_double - sz) <= ulp_dp(sz)/2) && \abs(vz_double - vz) <= ulp_dp(vz)/2) && \abs(TCOA_double - TCOA) <= ulp_dp(TCOA)/2) && \abs(ZTHR_double - ZTHR) <= ulp_dp(ZTHR)/2)))
                                                                                ==> ((\abs((\result.value - vertical_WCV_exit_minus_entry(B, T, sz, vz, TCOA, ZTHR))) <= 0x1.0400000000003p-46)))))) ;
*/
struct maybeDouble vertical_WCV_exit_minus_entry_num (double B_double, double T_double, double sz_double, double vz_double, double TCOA_double, double ZTHR_double) {
  return vertical_WCV_exit_minus_entry_fp (B_double, T_double, sz_double, vz_double, TCOA_double, ZTHR_double, 0x1p-52, 0x1.4000000000001p-49, 0x1.9000000000002p-48, 0x1.a000000000004p-47, 0x1.a000000000004p-47, 0x1.8p-51);
}


int main () { return 0; }