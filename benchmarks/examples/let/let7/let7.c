// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic real f (real X) =
(X * 2);
}
*/


/*@
axiomatic fp_function_f {
logic double f_fp (double X_double) =
Dmul(X_double, (double) (2));
}
*/


/*@
assigns \nothing;

behavior structure:
ensures ((\is_finite(\result) && \is_finite(X_double))
         ==> ((\result == f_fp(X_double)))) ;
*/
double f_fp (double X_double) {
  double res_double;
  res_double = (X_double * (double)(2));
  return res_double;
}


/*@
assigns \nothing;
ensures \forall real X; (((((0 <= X) && (X <= 10)) && (\is_finite(X_double) && \abs(X_double - X) <= ulp_dp(X)/2))
                          ==> ((\abs((\result - f(X))) <= 0x1p-50)))) ;
*/
double f_num (double X_double) {
  return f_fp (X_double);
}


/*@
axiomatic real_function_h {
logic real h (real X) =
(X * 3);
}
*/


/*@
axiomatic fp_function_h {
logic double h_fp (double X_double) =
Dmul(X_double, (double) (3));
}
*/


/*@
assigns \nothing;

behavior structure:
ensures ((\is_finite(\result) && \is_finite(X_double))
         ==> ((\result == h_fp(X_double)))) ;
*/
double h_fp (double X_double) {
  double res_double;
  res_double = (X_double * (double)(3));
  return res_double;
}


/*@
assigns \nothing;
ensures \forall real X; (((((0 <= X) && (X <= 10)) && (\is_finite(X_double) && \abs(X_double - X) <= ulp_dp(X)/2))
                          ==> ((\abs((\result - h(X))) <= 0x1.4p-48)))) ;
*/
double h_num (double X_double) {
  return h_fp (X_double);
}


/*@
axiomatic real_function_q {
logic real q (real X, real Y) =
(X * Y);
}
*/


/*@
axiomatic fp_function_q {
logic double q_fp (double X_double, double Y_double) =
Dmul(X_double, Y_double);
}
*/


/*@
assigns \nothing;

behavior structure:
ensures ((\is_finite(\result) && (\is_finite(X_double) && \is_finite(Y_double)))
         ==> ((\result == q_fp(X_double, Y_double)))) ;
*/
double q_fp (double X_double, double Y_double) {
  double res_double;
  res_double = (X_double * Y_double);
  return res_double;
}


/*@
assigns \nothing;
ensures \forall real X, real Y; ((((((0 <= X) && (X <= 60)) && ((0 <= Y) && (Y <= 60))) && ((\is_finite(X_double) && \is_finite(Y_double)) && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2)))
                                  ==> ((\abs((\result - q(X, Y))) <= 0x1.7000000000001p-41)))) ;
*/
double q_num (double X_double, double Y_double) {
  return q_fp (X_double, Y_double);
}


/*@
axiomatic real_pred_g {
logic boolean g (real X, real Y) =
\let a = f(X) ;
\let b = h(X) ;
\let c = (a + b) ;
(((c < 0))
 ? \true :
 ((c > 0))
 ? \false :
 \true);
}
*/


/*@
axiomatic fp_pred_g {
logic boolean g_fp (double X_double, double Y_double) =
\let a_double = f_fp(X_double) ;
\let b_double = h_fp(X_double) ;
\let c_double = Dadd(a_double, b_double) ;
(((c_double < (double) (0)))
 ? \true :
 ((c_double > (double) (0)))
 ? \false :
 \true);
}
*/


/*@ axiomatic g_tauplus_trans {
predicate g_tauplus_stable_paths (real X, real Y, double X_double, double Y_double) =
((((! (((f(X) + h(X)) > 0)) && ! (((f(X) + h(X)) < 0))) && ((! ((Dadd(f_fp(X_double), h_fp(X_double)) > (double) (0))) && ! ((Dadd(f_fp(X_double), h_fp(X_double)) < (double) (0)))) && (\true && \true))) || ((((f(X) + h(X)) > 0) && ! (((f(X) + h(X)) < 0))) && (((Dadd(f_fp(X_double), h_fp(X_double)) > (double) (0)) && ! ((Dadd(f_fp(X_double), h_fp(X_double)) < (double) (0)))) && (\true && \true)))) || (((f(X) + h(X)) < 0) && ((Dadd(f_fp(X_double), h_fp(X_double)) < (double) (0)) && (\true && \true))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures \forall real X, real Y; (((\result.isValid && ((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)))
                                  ==> ((\result.value
                                        ==> ((g(X, Y) && g_fp(X_double, Y_double))))))) ;

behavior stable_paths:
ensures \forall real X, real Y; ((\let a_double = f_fp(X_double);
                                  (\let a = f(X);
                                   (\let b_double = h_fp(X_double);
                                    (\let b = h(X);
                                     (\let c_double = Dadd(a_double, b_double);
                                      (\let c = (a + b);
                                       (\abs(c_double - c) <= E_0_double))))))
                                  ==> (((((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)) && \result.isValid)
                                        ==> (g_tauplus_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeBool g_tauplus_fp (double X_double, double Y_double, double E_0_double) {
  struct maybeBool res;
  double a_double = f_fp (X_double);
  double b_double = h_fp (X_double);
  double c_double = (a_double + b_double);
  if (c_double < - (E_0_double))
  { res = someBool(true);;
  }
  else if ((c_double > E_0_double) && (c_double >= E_0_double))
  { res = someBool(false);; }
  else if ((c_double <= - (E_0_double)) && (c_double >= E_0_double))
  { res = someBool(true);; }
  else { res = noneBool();
  }
  return res;
}


/*@
assigns \nothing;
ensures (\true
         ==> (\forall real X, real Y; ((((((0 <= X) && (X <= 60)) && ((0 <= Y) && (Y <= 60))) && ((\result.isValid && (\is_finite(X_double) && \is_finite(Y_double))) && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2)))
                                        ==> ((\result.value
                                              ==> (g(X, Y)))))))) ;
*/
struct maybeBool g_tauplus_num (double X_double, double Y_double) {
  return g_tauplus_fp (X_double, Y_double, 0x1p-44);
}




/*@ axiomatic g_tauminus_trans {
predicate g_tauminus_stable_paths (real X, real Y, double X_double, double Y_double) =
((((! (((f(X) + h(X)) > 0)) && ! (((f(X) + h(X)) < 0))) && ((! ((Dadd(f_fp(X_double), h_fp(X_double)) > (double) (0))) && ! ((Dadd(f_fp(X_double), h_fp(X_double)) < (double) (0)))) && (\true && \true))) || ((((f(X) + h(X)) > 0) && ! (((f(X) + h(X)) < 0))) && (((Dadd(f_fp(X_double), h_fp(X_double)) > (double) (0)) && ! ((Dadd(f_fp(X_double), h_fp(X_double)) < (double) (0)))) && (\true && \true)))) || (((f(X) + h(X)) < 0) && ((Dadd(f_fp(X_double), h_fp(X_double)) < (double) (0)) && (\true && \true))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures \forall real X, real Y; (((\result.isValid && ((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)))
                                  ==> ((\result.value
                                        ==> ((! (g(X, Y)) && ! (g_fp(X_double, Y_double)))))))) ;

behavior stable_paths:
ensures \forall real X, real Y; ((\let a_double = f_fp(X_double);
                                  (\let a = f(X);
                                   (\let b_double = h_fp(X_double);
                                    (\let b = h(X);
                                     (\let c_double = Dadd(a_double, b_double);
                                      (\let c = (a + b);
                                       (\abs(c_double - c) <= E_0_double))))))
                                  ==> (((((\is_finite(X_double) && \is_finite(Y_double)) && \is_finite(E_0_double)) && \result.isValid)
                                        ==> (g_tauminus_stable_paths(X, Y, X_double, Y_double)))))) ;
*/
struct maybeBool g_tauminus_fp (double X_double, double Y_double, double E_0_double) {
  struct maybeBool res;
  double a_double = f_fp (X_double);
  double b_double = h_fp (X_double);
  double c_double = (a_double + b_double);
  if (c_double < - (E_0_double))
  { res = someBool(false);;
  }
  else if ((c_double > E_0_double) && (c_double >= E_0_double))
  { res = someBool(true);; }
  else if ((c_double <= - (E_0_double)) && (c_double >= E_0_double))
  { res = someBool(false);; }
  else { res = noneBool();
  }
  return res;
}


/*@
assigns \nothing;
ensures (\true
         ==> (\forall real X, real Y; ((((((0 <= X) && (X <= 60)) && ((0 <= Y) && (Y <= 60))) && ((\result.isValid && (\is_finite(X_double) && \is_finite(Y_double))) && (\abs(X_double - X) <= ulp_dp(X)/2 && \abs(Y_double - Y) <= ulp_dp(Y)/2)))
                                        ==> ((\result.value
                                              ==> (! (g(X, Y))))))))) ;
*/
struct maybeBool g_tauminus_num (double X_double, double Y_double) {
  return g_tauminus_fp (X_double, Y_double, 0x1p-44);
}


int main () { return 0; }