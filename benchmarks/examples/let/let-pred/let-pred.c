// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic real f (real a) =
((a - 6) > 0) ? (((a * 3) - 7)) : ((a * 2));
}
*/


/*@
axiomatic fp_function_f {
logic double f_fp (double a_double) =
(Dsub(a_double, (double) (6)) > (double) (0)) ? (Dsub(Dmul(a_double, (double) (3)), (double) (7))) : (Dmul(a_double, (double) (2)));
}
*/


/*@ axiomatic f_trans {
predicate f_stable_paths (real a, double a_double) =
((! (((a - 6) > 0)) && (! ((Dsub(a_double, (double) (6)) > (double) (0))) && (\true && \true))) || (((a - 6) > 0) && ((Dsub(a_double, (double) (6)) > (double) (0)) && (\true && \true))));
}
*/


/*@
requires (0 <= E_0_double) ;
assigns \nothing;

behavior structure:
ensures ((\result.isValid && (\is_finite(\result.value) && (\is_finite(a_double) && \is_finite(E_0_double))))
         ==> ((\result.value == f_fp(a_double)))) ;

behavior stable_paths:
ensures \forall real a; ((\abs(Dsub(a_double, (double) (6)) - (a - 6)) <= E_0_double
                          ==> ((((\is_finite(a_double) && \is_finite(E_0_double)) && \result.isValid)
                                ==> (f_stable_paths(a, a_double)))))) ;
*/
struct maybeDouble f_fp (double a_double, double E_0_double) {
  struct maybeDouble res_double;
  if ((a_double - (double)(6)) > E_0_double)
  { res_double = someDouble(((a_double * (double)(3)) - (double)(7)));
  } else { if ((a_double - (double)(6)) <= - (E_0_double))
           { res_double = someDouble((a_double * (double)(2)));
           } else { res_double = noneDouble();
           }
  }
  return res_double;
}


/*@
assigns \nothing;
ensures \forall real a; (((((0 <= a) && (a <= 10)) && ((\result.isValid && \is_finite(a_double)) && \abs(a_double - a) <= ulp_dp(a)/2))
                          ==> ((\abs((\result.value - f(a))) <= 0x1.cp-48)))) ;
*/
struct maybeDouble f_num (double a_double) {
  return f_fp (a_double, 0x1.8p-50);
}


/*@
axiomatic real_pred_p {
logic boolean p (real a) =
\let aux = f(a) ;
((aux < 0));
}
*/


/*@
axiomatic fp_pred_p {
logic boolean p_fp (double a_double) =
\let aux_double = f_fp(a_double) ;
((aux_double < (double) (0)));
}
*/


/*@ axiomatic p_tauplus_trans {
predicate p_tauplus_stable_paths (real a, double a_double) =
((((! (((a - 6) > 0)) && (! ((Dsub(a_double, (double) (6)) > (double) (0))) && (\true && \true))) || (((a - 6) > 0) && ((Dsub(a_double, (double) (6)) > (double) (0)) && (\true && \true)))) || (! (((a - 6) > 0)) && (! ((Dsub(a_double, (double) (6)) > (double) (0))) && (\true && \true)))) || (((a - 6) > 0) && ((Dsub(a_double, (double) (6)) > (double) (0)) && (\true && \true))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures \forall real a; (((\result.isValid && ((\is_finite(a_double) && \is_finite(E_0_double)) && \is_finite(E_1_double)))
                          ==> ((\result.value
                                ==> ((p(a) && p_fp(a_double))))))) ;

behavior stable_paths:
ensures \forall real a; (((\abs(Dsub(a_double, (double) (6)) - (a - 6)) <= E_0_double && \let aux_double = f_fp(a_double);
                                                                                         (\let aux = f(a);
                                                                                          (\abs(aux_double - aux) <= E_1_double)))
                          ==> (((((\is_finite(a_double) && \is_finite(E_0_double)) && \is_finite(E_1_double)) && \result.isValid)
                                ==> (p_tauplus_stable_paths(a, a_double)))))) ;
*/
struct maybeBool p_tauplus_fp (double a_double, double E_0_double, double E_1_double) {
  struct maybeBool res;
  struct maybeDouble aux_0_double = f_fp (a_double, E_0_double);
  if (aux_0_double.isValid)
  { double aux_double = aux_0_double.value;
    res = someBool(aux_double < - (E_1_double));
  } else { res = noneBool();
  }
  return res;
}


/*@
assigns \nothing;
ensures (\true
         ==> (\forall real a; (((((0 <= a) && (a <= 10)) && ((\result.isValid && \is_finite(a_double)) && \abs(a_double - a) <= ulp_dp(a)/2))
                                ==> ((\result.value
                                      ==> (p(a)))))))) ;
*/
struct maybeBool p_tauplus_num (double a_double) {
  return p_tauplus_fp (a_double, 0x1.8p-50, 0x1.cp-48);
}




/*@ axiomatic p_tauminus_trans {
predicate p_tauminus_stable_paths (real a, double a_double) =
((((! (((a - 6) > 0)) && (! ((Dsub(a_double, (double) (6)) > (double) (0))) && (\true && \true))) || (((a - 6) > 0) && ((Dsub(a_double, (double) (6)) > (double) (0)) && (\true && \true)))) || (! (((a - 6) > 0)) && (! ((Dsub(a_double, (double) (6)) > (double) (0))) && (\true && \true)))) || (((a - 6) > 0) && ((Dsub(a_double, (double) (6)) > (double) (0)) && (\true && \true))));
}
*/


/*@
requires ((0 <= E_0_double) && (0 <= E_1_double)) ;
assigns \nothing;

behavior structure:
ensures \forall real a; (((\result.isValid && ((\is_finite(a_double) && \is_finite(E_0_double)) && \is_finite(E_1_double)))
                          ==> ((\result.value
                                ==> ((! (p(a)) && ! (p_fp(a_double)))))))) ;

behavior stable_paths:
ensures \forall real a; (((\abs(Dsub(a_double, (double) (6)) - (a - 6)) <= E_0_double && \let aux_double = f_fp(a_double);
                                                                                         (\let aux = f(a);
                                                                                          (\abs(aux_double - aux) <= E_1_double)))
                          ==> (((((\is_finite(a_double) && \is_finite(E_0_double)) && \is_finite(E_1_double)) && \result.isValid)
                                ==> (p_tauminus_stable_paths(a, a_double)))))) ;
*/
struct maybeBool p_tauminus_fp (double a_double, double E_0_double, double E_1_double) {
  struct maybeBool res;
  struct maybeDouble aux_0_double = f_fp (a_double, E_0_double);
  if (aux_0_double.isValid)
  { double aux_double = aux_0_double.value;
    res = someBool(aux_double >= E_1_double);
  } else { res = noneBool();
  }
  return res;
}


/*@
assigns \nothing;
ensures (\true
         ==> (\forall real a; (((((0 <= a) && (a <= 10)) && ((\result.isValid && \is_finite(a_double)) && \abs(a_double - a) <= ulp_dp(a)/2))
                                ==> ((\result.value
                                      ==> (! (p(a))))))))) ;
*/
struct maybeBool p_tauminus_num (double a_double) {
  return p_tauminus_fp (a_double, 0x1.8p-50, 0x1.cp-48);
}


int main () { return 0; }